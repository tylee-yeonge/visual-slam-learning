# Week 5: 강체 변환 (Rigid Body Transformation)

## 📌 개요

**강체 변환(Rigid Body Transformation)** 은 물체의 형태를 변형시키지 않고 위치와 방향만 바꾸는 변환입니다. 3D 공간에서 **회전(Rotation) + 평행이동(Translation)** 을 결합한 것으로, SLAM에서 카메라나 로봇의 **포즈(Pose)** 를 표현하는 핵심 개념입니다.

```
    변환 전                    변환 후
    
      ■                          ■
     ■■■    ──회전+이동──→      ■■■
      ■                          ■
      
형태는 그대로! 위치와 방향만 변경
```

> [!NOTE]
> **강체 변환의 핵심**: 물체의 **크기**와 **형태**는 보존되고, **위치**와 **방향**만 변합니다.

---

## 🎯 학습 목표

이번 주차를 완료하면 다음을 할 수 있습니다:

1. ✅ SE(3) 변환 행렬의 구조를 이해하고 생성할 수 있다
2. ✅ 동차 좌표(Homogeneous Coordinates)의 장점을 설명할 수 있다
3. ✅ SE(3) 역변환 공식을 유도하고 계산할 수 있다
4. ✅ 좌표계 변환과 상대 포즈를 이해할 수 있다
5. ✅ ROS TF2와 변환 행렬의 관계를 이해할 수 있다

---

## 📚 사전 지식

- **Week 4**: 회전 표현 (회전 행렬, 쿼터니언)
- **기초 선형대수**: 행렬 곱셈

---

## ⏱️ 예상 학습 시간

| 항목 | 시간 |
|------|------|
| Part 1: SE(3) 기초 | 1.5시간 |
| Part 2: 동차 좌표 | 1시간 |
| Part 3: 변환 연산 | 1.5시간 |
| Part 4: 좌표계 변환 | 1.5시간 |
| Part 5: SLAM 응용 | 0.5시간 |
| **총 소요시간** | **6시간** |

---

# Part 1: SE(3) 변환 행렬

## 1.1 SE(3)란?

**SE(3)** = Special Euclidean Group (3D)

쉽게 말해, **3D 공간에서 가능한 모든 강체 변환의 집합**입니다.

```
SE(3) = { 모든 가능한 (회전 + 평행이동) 조합 }
```

| 용어 | 의미 |
|------|------|
| **S** (Special) | 반사(거울 변환) 제외, 회전만 포함 |
| **E** (Euclidean) | 유클리드 공간에서의 거리 보존 변환 |
| **(3)** | 3차원 공간 |

---

## 1.2 SE(3) 행렬의 구조

SE(3) 변환은 **4×4 행렬**로 표현됩니다:

```
T = [ R  | t ]  ∈ SE(3)
    [----+---]
    [ 0  | 1 ]

구체적으로:
    [ r11  r12  r13 | tx ]
T = [ r21  r22  r23 | ty ]
    [ r31  r32  r33 | tz ]
    [---------------+----]
    [  0    0    0  |  1 ]
```

### 각 부분의 의미

| 부분 | 크기 | 의미 |
|------|------|------|
| **R** | 3×3 | 회전 행렬 (SO(3)에 속함) |
| **t** | 3×1 | 평행이동 벡터 [tx, ty, tz] |
| **0** | 1×3 | 영 벡터 [0, 0, 0] |
| **1** | 스칼라 | 동차 좌표 유지용 |

---

## 1.3 SO(3)와 SE(3)의 관계

```
SO(3): 회전만 (3×3 행렬)
  ↓
SE(3): 회전 + 평행이동 (4×4 행렬)
```

```
SO(3) ⊂ SE(3)  (SO(3)는 SE(3)의 특수한 경우)

평행이동 없이 회전만 있는 경우:
T = [ R  | 0 ]  ← t = 0이면 순수 회전
    [----+---]
    [ 0  | 1 ]
```

---

## 1.4 왜 4×4 행렬인가?

### 문제: 3×3 행렬의 한계

```python
# 3×3 행렬로는...
p' = R @ p      # 회전만 가능!
p' = R @ p + t  # 평행이동은 별도 덧셈 필요...
```

### 해결: 4×4 행렬 + 동차 좌표

```python
# 4×4 행렬로는...
P' = T @ P  # 회전 + 이동이 한 번에!
```

---

## 1.5 SE(3) 변환이 하는 일

3D 점 `p = [x, y, z]`에 SE(3) 변환 T를 적용하면:

```
    [ r11  r12  r13 | tx ]   [ x ]     [ r11·x + r12·y + r13·z + tx ]
T @ [ r21  r22  r23 | ty ] @ [ y ]  =  [ r21·x + r22·y + r23·z + ty ]
    [ r31  r32  r33 | tz ]   [ z ]     [ r31·x + r32·y + r33·z + tz ]
    [  0    0    0  |  1 ]   [ 1 ]     [              1              ]
    
                                   =   [ R @ p + t ]
                                       [     1     ]
```

> [!IMPORTANT]
> **변환 순서**: SE(3)에서는 **회전이 먼저** 적용되고, 그 다음 **평행이동**이 적용됩니다!
> 
> `p' = R @ p + t`

---

## 1.6 실제 예시: 카메라 이동

```python
import numpy as np

# 상황: 카메라가 z축 기준 45도 회전 + x방향 2m, y방향 1m 이동

# 1. 회전 행렬 (z축 45도 회전)
theta = np.pi / 4  # 45도
R = np.array([
    [np.cos(theta), -np.sin(theta), 0],
    [np.sin(theta),  np.cos(theta), 0],
    [0,              0,              1]
])

# 2. 평행이동 벡터
t = np.array([2, 1, 0])

# 3. SE(3) 변환 행렬 생성
T = np.eye(4)
T[:3, :3] = R
T[:3, 3] = t

print("SE(3) 변환 행렬 T:")
print(T)
```

```
       변환 전                      변환 후
       
         Y                           Y
         │                           │
         │                           │    🎥 (2, 1)
         │                           │   ╱ 45° 회전
         🎥──────── X                └──────── X
       (0, 0)
       정면을 봄                    x=2, y=1 위치에서
                                    45도 회전된 방향을 봄
```

---

## 1.7 SE(3) 유틸리티 함수

```python
import numpy as np

def make_transform(R, t):
    """회전 행렬 R과 평행이동 벡터 t로 SE(3) 변환 행렬 생성"""
    T = np.eye(4)
    T[:3, :3] = R  # 좌측 상단 3×3에 회전 행렬
    T[:3, 3] = t   # 우측 상단 3×1에 평행이동 벡터
    return T

def decompose_transform(T):
    """SE(3) 변환 행렬에서 R과 t 추출"""
    R = T[:3, :3]
    t = T[:3, 3]
    return R, t
```

---

## 1.8 SE(3)의 자유도 (6-DOF)

**자유도(Degrees of Freedom)** 란 시스템을 완전히 기술하는 데 필요한 독립적인 변수의 개수입니다.

| 요소 | 자유도 | 설명 |
|------|--------|------|
| 회전 R | 3 | roll(x축), pitch(y축), yaw(z축) |
| 평행이동 t | 3 | x, y, z 방향 이동 |
| **총합** | **6** | 6 DOF |

```
       Y (pitch)
       │
       │    ╱ Z (roll)
       │   ╱
       │  ╱
       └─────── X (yaw)
       
   + x, y, z 이동 = 총 6 자유도
```

> [!TIP]
> SLAM에서 "6-DOF 포즈 추정"이라고 하면, 이 6개의 값(3개 회전 + 3개 이동)을 추정한다는 의미입니다!

---

# Part 2: 동차 좌표 (Homogeneous Coordinates)

## 2.1 동차 좌표란?

**동차 좌표**는 n차원 공간의 점을 **(n+1)개의 수**로 표현하는 좌표 시스템입니다.

```
n차원 유클리드 공간 → (n+1)차원 벡터로 표현

• 2D 점 (x, y)   → 동차 좌표 (x, y, w)
• 3D 점 (x, y, z) → 동차 좌표 (x, y, z, w)
```

---

## 2.2 핵심 특징: 스케일 불변성

동차 좌표의 가장 중요한 특징은 **0이 아닌 같은 배수로 곱한 좌표들이 모두 같은 점**을 나타낸다는 것입니다.

```
(x, y, w) ≡ (kx, ky, kw)  (k ≠ 0인 임의의 실수)
```

**예시**: 다음은 모두 2D 점 `(2, 3)`을 나타냅니다
```python
(2, 3, 1)        # 표준 형태 (w=1)
(4, 6, 2)        # 2배
(6, 9, 3)        # 3배
(10, 15, 5)      # 5배
(-2, -3, -1)     # -1배

# 모두 비율이 2:3:1로 같음!
```

---

## 2.3 좌표 변환 방법

### 동차 좌표 → 일반 좌표 (정규화)

```python
# 마지막 좌표 w로 나누기
(x_h, y_h, w) → (x_h/w, y_h/w)
(x_h, y_h, z_h, w) → (x_h/w, y_h/w, z_h/w)

# 예시
(6, 9, 3) → (6/3, 9/3) = (2, 3)
(2, 4, 6, 2) → (2/2, 4/2, 6/2) = (1, 2, 3)
```

### 일반 좌표 → 동차 좌표

```python
# 마지막에 1을 추가 (표준 형태)
(x, y) → (x, y, 1)
(x, y, z) → (x, y, z, 1)

# 코드 예시
p = np.array([x, y, z])
p_h = np.array([x, y, z, 1])  # w=1 추가

# 동차 좌표 → 일반 좌표
p = p_h[:3] / p_h[3]  # w로 나누기
```

---

## 2.4 기하학적 직관: 원점에서의 광선

동차 좌표 `(x, y, w)`는 **원점에서 출발하는 광선**으로 생각할 수 있습니다.

```
       (4,6,2)
         ↗
(2,3,1) ↗
      ↗
 원점 •―――――→ 이 광선 위의 모든 점
           (6,9,3)
           (8,12,4)
           ...
```

같은 광선 위의 모든 점들이 같은 동차 좌표를 나타내며, 이 광선이 `w=1` 평면과 만나는 점이 **실제 일반 좌표**입니다.

---

## 2.5 왜 동차 좌표를 사용하는가?

### 문제점 (일반 좌표)

```python
# 회전과 이동을 동시에 하려면 두 가지 연산 필요
p' = R @ p + t  # 행렬 곱셈 + 벡터 덧셈
```

### 해결책 (동차 좌표)

```python
# 모든 변환을 하나의 행렬 곱셈으로!
P' = T @ P  # 행렬 곱셈만!
```

### 작동 원리

```
      [r11 r12 r13 tx]   [x]   [r11·x + r12·y + r13·z + tx·1]
P' =  [r21 r22 r23 ty] @ [y] = [r21·x + r22·y + r23·z + ty·1]
      [r31 r32 r33 tz]   [z]   [r31·x + r32·y + r33·z + tz·1]
      [ 0   0   0  1 ]   [1]   [          0  +  0  +  1         ]
      
      [R @ p + t]
    = [    ...    ]  ← 회전 + 이동이 한 번에!
      [    ...    ]
      [     1     ]
```

마지막 원소가 `1`이기 때문에 `tx·1 = tx`가 되어 이동 항이 자동으로 더해집니다!

---

## 2.6 동차 좌표의 장점

| 장점 | 설명 |
|------|------|
| **연산 통일** | 회전과 평행이동을 행렬 곱셈 하나로 처리 |
| **변환 합성** | 여러 변환을 행렬 곱으로 쉽게 합성 |
| **투영 변환** | 카메라 투영도 행렬 곱셈으로 표현 가능 |
| **무한원점** | `w=0`으로 무한히 먼 점(방향 벡터) 표현 가능 |

```python
# 변환 합성 예시
T_total = T3 @ T2 @ T1  # 행렬끼리만 곱하면 됨!
P_final = T_total @ P
```

---

# Part 3: 변환 연산

## 3.1 변환 합성

```python
# 연속 변환: 먼저 T1, 그 다음 T2 적용
T_combined = T2 @ T1
```

> [!WARNING]
> **변환 순서 주의!** T2 @ T1 ≠ T1 @ T2
> 
> 행렬 곱셈은 교환법칙이 성립하지 않습니다!

---

## 3.2 역변환

SE(3)의 역변환 **T⁻¹**는 다음과 같이 표현됩니다:

```
T⁻¹ = [ R^T | -R^T @ t ]
      [-----+---------]
      [  0  |    1     ]
```

> [!NOTE]
> 일반 행렬의 역행렬 계산은 복잡하지만, SE(3)는 특수한 구조 덕분에 간단한 공식이 존재합니다!

---

## 3.3 역변환 공식의 수학적 유도

### Step 1: 역행렬의 형태 가정

역행렬의 정의 T · T⁻¹ = I를 이용하여 T⁻¹를 구합니다:

```
T = [R  t]      T⁻¹ = [A  b]
    [0  1]            [c  d]
```

### Step 2: T · T⁻¹ = I 전개

```
[R  t] · [A  b]  = [I  0]
[0  1]   [c  d]    [0  1]
```

블록 행렬의 곱셈을 적용하면:

```
[R·A + t·c    R·b + t·d]  = [I  0]
[0·A + 1·c    0·b + 1·d]    [0  1]
```

### Step 3: 각 블록을 하나씩 풀기

| 블록 위치 | 식 | 결과 |
|----------|----|------|
| 우측 하단 | 1·d = 1 | d = 1 |
| 좌측 하단 | 0·A + 1·c = 0 | c = 0 |
| 좌측 상단 | R·A = I | A = R⁻¹ = **R^T** |
| 우측 상단 | R·b + t = 0 | b = **-R^T·t** |

---

## 3.4 왜 R⁻¹ = R^T 인가?

회전 행렬 R은 **직교 행렬(Orthogonal Matrix)** 입니다:

- 각 열(또는 행)은 **정규 직교 기저 벡터**
- 각 열 벡터의 크기: ||r₁|| = ||r₂|| = ||r₃|| = 1
- 열 벡터들은 서로 직교: r₁·r₂ = r₁·r₃ = r₂·r₃ = 0

직교 행렬의 핵심 성질:
```
R^T · R = R · R^T = I  →  R⁻¹ = R^T
```

---

## 3.5 SE(3) 전체는 직교 행렬이 아니다!

> [!WARNING]
> **회전 부분 R만** 직교 행렬이고, **SE(3) 전체 T는** 직교 행렬이 아닙니다!

```python
# SE(3)가 직교 행렬인지 확인
T.T @ T ≠ I  # 직교 행렬 조건 불만족!
```

| | 직교 행렬인가? | 역행렬 |
|---|---|---|
| **R** (회전 부분) | ✅ Yes | R^T |
| **T** (SE(3) 전체) | ❌ No | [R^T, -R^T·t; 0, 1] |

---

## 3.6 왜 단순히 -t가 아닌가?

평행이동 벡터 **t**는 **회전된 좌표계에서의 이동**을 나타냅니다.

### 순변환 (A → B)
```
p_B = R·p_A + t
```
1. 먼저 회전: R·p_A
2. 그 다음 평행이동: + t

### 역변환 (B → A)
```
p_A = R^T·(p_B - t) = R^T·p_B - R^T·t
```
1. 먼저 평행이동 취소: p_B - t
2. 그 다음 역회전: R^T·(...)

> [!IMPORTANT]
> **핵심**: 역변환은 **역순**으로 진행됩니다! 평행이동을 취소한 후 역회전을 적용해야 하므로, 최종적으로 **-R^T·t**가 됩니다.

---

## 3.7 역변환 코드 예시

```python
import numpy as np

def inverse_transform(T):
    """SE(3) 역변환"""
    R = T[:3, :3]
    t = T[:3, 3]
    
    T_inv = np.eye(4)
    T_inv[:3, :3] = R.T
    T_inv[:3, 3] = -R.T @ t
    return T_inv

# 예시: 90도 z축 회전 + [3, 0, 0] 평행이동
theta = np.pi / 2
R = np.array([
    [np.cos(theta), -np.sin(theta), 0],
    [np.sin(theta),  np.cos(theta), 0],
    [0,              0,              1]
])
t = np.array([3, 0, 0])

T = np.eye(4)
T[:3, :3] = R
T[:3, 3] = t

T_inv = inverse_transform(T)

# 검증: T @ T_inv = I
print(np.allclose(T @ T_inv, np.eye(4)))  # True

# -R^T·t의 결과 확인
print(-R.T @ t)  # [0. -3.  0.] ← x방향 3이동이 y방향 -3이동으로 변환됨
```

---

# Part 4: 좌표계 변환

## 4.1 좌표계란?

**좌표계(Coordinate Frame)** 는 공간에서 위치를 측정하는 **기준점**과 **기준 방향**입니다.

```
       Y(위)
       │
       │
       │
       └──────── X(앞)
      ╱
     ╱
    Z(오른쪽)
    
    └─ 이것이 하나의 "좌표계"
       (원점 + 3개의 축 방향)
```

> [!NOTE]
> **핵심 개념**: 공간에서 같은 물체라도, **어떤 좌표계를 기준으로 보느냐**에 따라 좌표값이 달라집니다!

**예시**: 친구가 "내 앞에 3m 있어"라고 말했을 때
- 친구의 좌표계에서: (3, 0, 0)
- 내 좌표계에서는: 친구의 위치와 방향에 따라 다른 값!

---

## 4.2 T 표기법 이해하기

SE(3) 변환 행렬 **T**의 아래첨자 표기법:

```
T_ab  →  "a 좌표계에서 본 b의 포즈"
      또는
      "b 좌표계의 점을 a 좌표계로 변환"
```

> [!IMPORTANT]
> **T_ab @ p_b = p_a**
> 
> - p_b: b 좌표계에서 표현된 점
> - p_a: 같은 점을 a 좌표계에서 표현한 것
> - T_ab: b → a로 변환하는 행렬

### 외우는 팁

아래첨자를 연결해서 읽으면 됩니다!

```
T_ab @ p_b = p_a
    ↑    ↑
    b가 상쇄됨 → a만 남음!
```

---

## 4.3 월드 ↔ 카메라 변환

SLAM에서 가장 많이 쓰는 두 좌표계:
- **월드 좌표계 (W)**: 지도의 기준점. 고정되어 있음
- **카메라 좌표계 (C)**: 카메라를 기준으로 한 좌표계. 카메라가 움직이면 함께 이동

```
    월드 좌표계 (W)                    카메라 좌표계 (C)
         Y                                   Y
         │                                   │
         │     🎥                            │
         │    ╱ ← 카메라                     │
         └──────── X                         └──────── X
        ╱                                   ╱
       Z                                   Z
                                           (카메라 기준)
```

### T_wc: 카메라의 포즈

```
T_wc = 카메라가 월드에서 어디 있는지, 어디를 바라보는지

T_wc = [ R_wc | t_wc ]
       [------+------]
       [  0   |  1   ]

- R_wc: 카메라가 어느 방향을 바라보는지 (회전)
- t_wc: 카메라가 월드 어디에 있는지 (위치)
```

> [!TIP]
> **이것이 바로 SLAM에서 추정하는 "카메라 포즈"입니다!**

### T_cw: 월드 → 카메라 변환

```python
T_cw = T_wc⁻¹  # 역변환!
```

```
T_cw @ p_world = p_camera
```

**의미**: 월드에 있는 점을 카메라 시점에서 바라보면 어떻게 보이는가?

---

## 4.4 예시: 3D 점을 카메라로 바라보기

```python
import numpy as np

# 월드 좌표계에서 (5, 0, 0)에 있는 점
p_world = np.array([5, 0, 0, 1])  # 동차 좌표

# 카메라 포즈: 원점에서 90도 왼쪽으로 회전, x방향으로 2m 이동
theta = np.pi / 2  # 90도
R_wc = np.array([
    [np.cos(theta), -np.sin(theta), 0],
    [np.sin(theta),  np.cos(theta), 0],
    [0,              0,              1]
])
t_wc = np.array([2, 0, 0])

# T_wc 생성
T_wc = np.eye(4)
T_wc[:3, :3] = R_wc
T_wc[:3, 3] = t_wc

# T_cw = T_wc의 역변환
T_cw = np.eye(4)
T_cw[:3, :3] = R_wc.T
T_cw[:3, 3] = -R_wc.T @ t_wc

# 월드 점을 카메라 좌표로 변환
p_camera = T_cw @ p_world
print("월드 좌표:", p_world[:3])     # [5. 0. 0.]
print("카메라 좌표:", p_camera[:3])  # [0. 3. 0.]
```

```
      월드 좌표계                 카메라가 보는 시점
      
          Y                            Y
          │                            │
      🎥 ─┼───●(5,0,0)                 ●(0,3,0)
       ↑  │                            │
       │  └─── X                       └─── X
     (2,0)                          
     
   카메라는 왼쪽(+Y)을             카메라 입장에서
   바라보고 있음                   점은 앞쪽(+Y)에 있음!
```

---

## 4.5 상대 포즈

**상대 포즈**란 두 좌표계(예: 두 카메라 위치) 사이의 상대적인 변환입니다.

### 왜 상대 포즈가 필요한가?

SLAM에서는 키프레임(중요한 이미지 프레임)들 사이의 관계를 저장합니다:
- 절대 포즈: "프레임 i가 월드에서 어디 있는지" → T_wi
- **상대 포즈**: "프레임 i 기준으로 프레임 j가 어디 있는지" → T_ij

| 활용 | 설명 |
|------|------|
| **인접 프레임 비교** | 카메라가 얼마나 움직였는지 직접적으로 알 수 있음 |
| **루프 클로저** | 이전에 방문한 곳으로 돌아왔을 때 누적 오차 보정 |
| **그래프 최적화** | 포즈 그래프에서 엣지로 사용 |

---

## 4.6 상대 포즈 계산

```
T_ij = T_wj⁻¹ @ T_wi
     = T_jw @ T_wi
```

**의미**: i 좌표계에서 본 j의 포즈

```
    월드 (W)
      │
      ├── T_wi ──→ 프레임 i
      │
      └── T_wj ──→ 프레임 j
      
      
      T_ij = ?  (i에서 j로 가는 변환)
```

### 유도 과정

```
1. i 좌표계의 점 p_i를 월드로: p_w = T_wi @ p_i
2. 월드 점을 j 좌표계로:      p_j = T_jw @ p_w
3. 합치면:                   p_j = T_jw @ T_wi @ p_i
                                 = T_ji @ p_i

따라서: T_ji = T_jw @ T_wi = T_wj⁻¹ @ T_wi
```

> [!TIP]
> **아래첨자 연결 팁**: T_jw @ T_wi에서 `w`가 상쇄되어 T_ji가 됨!

---

## 4.7 상대 포즈 코드 예시

```python
import numpy as np

# 프레임 1: 원점에서 정면을 봄
T_w1 = np.eye(4)

# 프레임 2: x방향 2m 이동, z축으로 30도 회전
theta = np.pi / 6  # 30도
R2 = np.array([
    [np.cos(theta), -np.sin(theta), 0],
    [np.sin(theta),  np.cos(theta), 0],
    [0,              0,              1]
])
t2 = np.array([2, 0, 0])

T_w2 = np.eye(4)
T_w2[:3, :3] = R2
T_w2[:3, 3] = t2

# 상대 포즈 T_12: 프레임 1 기준으로 프레임 2가 어디 있는지
# T_12 = T_1w @ T_w2 = T_w1⁻¹ @ T_w2

T_1w = np.linalg.inv(T_w1)  # = I (프레임 1이 원점이므로)
T_12 = T_1w @ T_w2

print("상대 포즈 T_12:")
print(T_12)
```

```
      월드/프레임1                   프레임1 기준으로
       (같은 위치)                   프레임2 위치
       
          Y                              Y
          │                              │
          │                              │   ↗ 🎥 프레임2
          │                              │ ╱  (30° 회전)
          └───────── X                   └────●───── X
         🎥                                   2m
       프레임1
       
       T_12 = 프레임 1에서 본 프레임 2
            = x방향 2m 이동 + 30도 회전
```

---

# Part 5: SLAM에서의 활용

## 5.1 카메라 포즈 표현

```
T_wc = [ R_wc | t_wc ]
       [-----+-----]
       [  0  |  1  ]

- R_wc: 카메라 방향 (월드 기준)
- t_wc: 카메라 위치 (월드 기준)
```

---

## 5.2 3D 점 투영

```python
def project_point(P_world, T_cw, K):
    """3D 월드 점 → 2D 이미지 좌표"""
    # 월드 → 카메라 변환
    P_cam = T_cw @ np.append(P_world, 1)
    P_cam = P_cam[:3]
    
    # 정규화 좌표
    x_norm = P_cam[0] / P_cam[2]
    y_norm = P_cam[1] / P_cam[2]
    
    # 픽셀 좌표
    p = K @ np.array([x_norm, y_norm, 1])
    return p[:2]
```

---

## 5.3 ROS TF2 연결

```python
# geometry_msgs/Transform 구조
# - translation: Vector3 (x, y, z)
# - rotation: Quaternion (x, y, z, w)

# SE(3) → TF2 메시지
def se3_to_transform(T):
    from geometry_msgs.msg import Transform, Vector3, Quaternion
    
    t = Transform()
    t.translation = Vector3(x=T[0,3], y=T[1,3], z=T[2,3])
    
    q = rotation_matrix_to_quaternion(T[:3,:3])
    t.rotation = Quaternion(x=q[1], y=q[2], z=q[3], w=q[0])
    
    return t
```

---

# 📊 요약

## 핵심 개념 정리표

| 개념 | 크기 | 자유도 | 용도 |
|------|------|--------|------|
| 회전 행렬 R | 3×3 | 3 | 방향 표현 |
| 쿼터니언 q | 4×1 | 3 | 방향 표현 |
| 평행이동 t | 3×1 | 3 | 위치 표현 |
| SE(3) 변환 T | 4×4 | 6 | 포즈 표현 |

## 핵심 공식

| 연산 | 공식 |
|------|------|
| SE(3) 구조 | T = [R, t; 0, 1] |
| 역변환 | T⁻¹ = [R^T, -R^T·t; 0, 1] |
| 변환 합성 | T_combined = T2 @ T1 |
| 좌표 변환 | T_ab @ p_b = p_a |
| 상대 포즈 | T_ij = T_wi⁻¹ @ T_wj |

---

# 💻 실습 파일

| 파일 | 내용 |
|------|------|
| `se3_basics.py` | SE(3) 변환 행렬 생성 및 연산 |
| `se3_quiz.py` | 주관식 퀴즈 |

### 실행 방법

```bash
cd "Studies/Phase 1/week5"
python3 se3_basics.py
python3 se3_quiz.py
```

---

# 🎬 추천 영상

| 영상 | 설명 |
|------|------|
| [Cyrill Stachniss - SE(3)](https://www.youtube.com/watch?v=khGGoAAl1c4) | SE(3) 이론 |
| [ROS TF Tutorial](http://wiki.ros.org/tf2/Tutorials) | TF2 사용법 |

---

# ✅ 학습 완료 체크리스트

- [ ] SE(3) 4×4 변환 행렬의 구조를 그릴 수 있다
- [ ] 동차 좌표의 장점 3가지를 설명할 수 있다
- [ ] 두 변환의 합성 순서를 올바르게 적용할 수 있다
- [ ] 역변환 공식 T⁻¹ = [R^T, -R^T·t]를 유도할 수 있다
- [ ] T_ab 표기법의 의미를 설명할 수 있다
- [ ] 상대 포즈 계산을 수행할 수 있다
- [ ] ROS TF2 메시지와 SE(3)의 관계를 안다

---

# 🔗 다음 단계

Week 5 완료 후 → **Week 6: Lie 군/대수 기초**로 이동
- 왜 over-parameterized인지
- SE(3)의 접선 공간
- 최적화에서의 활용
