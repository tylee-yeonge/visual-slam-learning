# Week 2: NumPy/Eigen 기본 연산 실습

## 📌 개요

Week 1에서 3Blue1Brown 영상을 통해 선형대수의 **직관**을 얻었다면, 이번 주에는 **직접 코드로 구현**하면서 개념을 확실히 다집니다. 행렬 곱셈, 역행렬, 고유값 분해, 행렬식 등 핵심 연산을 NumPy로 실습하고, 이것이 SLAM에서 어떻게 활용되는지 연결합니다.

특히 **회전 행렬의 성질**과 **공분산 행렬**은 Visual SLAM의 거의 모든 알고리즘에서 등장하므로 이번 주에 확실히 이해해야 합니다.

## 🎯 학습 목표

1. NumPy로 기본 선형대수 연산 수행하기
2. 행렬 곱셈의 기하학적 의미 이해
3. 고유값/고유벡터를 코드로 계산하고 의미 파악
4. 회전 행렬이 직교 행렬인 이유 이해
5. 공분산 행렬로 불확실성 표현하기 (칼만 필터 예고)

## 📚 사전 지식

- Week 1 완료 (3Blue1Brown Essence of Linear Algebra)
- Python 기본 문법
- NumPy 기초 (`import numpy as np`, 배열 생성)

## ⏱️ 예상 학습 시간

| 항목 | 시간 |
|------|------|
| 이론 복습 | 1시간 |
| 실습 예제 | 2-3시간 |
| SLAM 연결 이해 | 1-2시간 |
| 퀴즈 풀이 | 1시간 |
| **총 소요시간** | **5-7시간** |

---

## 📖 핵심 개념

### 1. 행렬 곱셈 (Matrix Multiplication)

```python
import numpy as np

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

# 행렬 곱셈
C = A @ B  # 또는 np.dot(A, B)
```

**기하학적 의미**: 행렬 곱셈 `AB`는 두 선형 변환의 **합성(composition)** 입니다.
- 먼저 B로 변환, 그 다음 A로 변환

### 2. 역행렬 (Inverse Matrix)

```python
A = np.array([[4, 7], [2, 6]])
A_inv = np.linalg.inv(A)

# 검증: A @ A^(-1) = I
print(A @ A_inv)  # [[1, 0], [0, 1]]
```

**SLAM 활용**: 좌표계 변환의 역변환
- 카메라 → 월드, 월드 → 카메라 변환

### 3. 고유값 분해 (Eigenvalue Decomposition) - 기초부터 이해하기

#### 고유값/고유벡터란 무엇인가?

행렬은 벡터를 **변환(transform)** 시킵니다. 대부분의 벡터는 변환 후 방향이 바뀌지만, 
**특별한 벡터** 는 방향이 바뀌지 않고 **크기만 늘어나거나 줄어듭니다**.

이런 특별한 벡터를 **고유벡터(eigenvector)**, 크기 변화량을 **고유값(eigenvalue)** 이라고 합니다.

행렬의 **입력과 출력의 차원 개수(행과 열의 개수)** 가 같아야 합니다.

```
수식 정의: A·v = λ·v

- A: 행렬
- v: 고유벡터 (방향이 안 바뀌는 벡터)
- λ: 고유값 (크기 변화량)
```

결국, 고유값 분해는 **해당 행렬의 고유값과 고유벡터를 구하는 과정** 입니다.

#### 시각적 이해

```
        변환 전              행렬 A 적용               변환 후
        
    ↗ v₁ (고유벡터)    →    A·v₁ = λ₁·v₁    →    ↗ 같은 방향, 크기만 λ₁배
   /                                            /
  ●─────────────→                           ●────────────────→
      일반 벡터 u   →       A·u              →    방향도 바뀜!
```

- **고유벡터 v₁**: 방향 유지, 크기만 λ₁배
- **일반 벡터 u**: 방향도 바뀜

#### 간단한 예제

```python
import numpy as np

# 대각 행렬 예제 (가장 간단)
A = np.array([
    [2, 0],
    [0, 3]
])  # x방향 2배, y방향 3배 스케일링

# x축 방향 벡터
v1 = np.array([1, 0])
print(f"A @ v1 = {A @ v1}")  # [2, 0] = 2 * [1, 0]
# → v1은 고유벡터, 고유값 = 2

# y축 방향 벡터
v2 = np.array([0, 1])
print(f"A @ v2 = {A @ v2}")  # [0, 3] = 3 * [0, 1]
# → v2도 고유벡터, 고유값 = 3
```

> [!NOTE]
> **대각 행렬의 비밀**: 대각 행렬의 고유값 = 대각 원소, 고유벡터 = 좌표축 방향!

#### NumPy로 고유값 분해하기

```python
# 일반 행렬
A = np.array([
    [4, 2],
    [2, 3]
])

# 고유값 분해
eigenvalues, eigenvectors = np.linalg.eig(A)

print("고유값:", eigenvalues)
# [5.56, 1.44]

print("고유벡터 (각 열이 하나의 고유벡터):")
print(eigenvectors)
```

#### 검증: A·v = λ·v 확인

```python
# 첫 번째 고유벡터
v1 = eigenvectors[:, 0]
lambda1 = eigenvalues[0]

# A @ v1 과 lambda1 * v1 비교
print(f"A @ v1 = {A @ v1}")
print(f"λ1 * v1 = {lambda1 * v1}")
print(f"같은가? {np.allclose(A @ v1, lambda1 * v1)}")  # True!
```

#### 기하학적 의미

행렬 A의 고유값 분해는 변환의 **본질적인 방향과 크기**를 알려줍니다:

```
A = V · Λ · V⁻¹

V: 고유벡터들 (변환의 주축 방향)
Λ: 고유값 대각행렬 (각 축의 스케일)
```

쉽게 말하면:
1. **고유벡터**: "이 행렬이 가장 자연스럽게 작용하는 방향"
2. **고유값**: "그 방향으로 얼마나 늘리기/줄이기 하는가"

#### 대칭 행렬의 특별한 성질

**대칭 행렬** (Aᵀ = A)은 특별히 좋은 성질이 있습니다:

```python
# 대칭 행렬 (공분산 행렬도 대칭!)
A_sym = np.array([
    [4, 2],
    [2, 3]
])

eigenvalues, eigenvectors = np.linalg.eig(A_sym)

# 대칭 행렬의 특별한 성질:
# 1. 고유값이 항상 실수
print(f"고유값 (모두 실수): {eigenvalues}")

# 2. 고유벡터들이 서로 직교 (수직)
v1, v2 = eigenvectors[:, 0], eigenvectors[:, 1]
print(f"v1 · v2 = {np.dot(v1, v2):.10f}")  # ≈ 0 (직교!)
```

> [!TIP]
> SLAM의 공분산 행렬은 **대칭 행렬**이므로:
> - 고유값이 항상 양수 (분산은 음수가 될 수 없음)
> - 고유벡터들이 직교 (불확실성 타원의 수직 축)

#### SLAM에서의 활용: 공분산 행렬 분석

로봇 위치 추정의 **불확실성**을 분석할 때 고유값 분해를 사용합니다:

```python
# 로봇 위치 추정의 공분산 행렬
P = np.array([
    [0.04, 0.02],  # x분산=0.04, 공분산=0.02
    [0.02, 0.09]   # 공분산=0.02, y분산=0.09
])

eigenvalues, eigenvectors = np.linalg.eig(P)

print("고유값 (주축 방향의 분산):", eigenvalues)
print("고유벡터 (주축 방향):")
print(eigenvectors)

# 표준편차 (불확실성 타원의 반지름)
std_devs = np.sqrt(eigenvalues)
print(f"주축 1 표준편차: {std_devs[0]:.3f}")
print(f"주축 2 표준편차: {std_devs[1]:.3f}")
```

```
불확실성 타원 시각화:

         y
         ↑
         |    ╱╲
         |   ╱  ╲  ← 고유벡터 2 방향
         |  ╱    ╲    (작은 불확실성)
    ─────●─────────→ x
         ╲      ╱
          ╲    ╱  ← 고유벡터 1 방향
           ╲  ╱     (큰 불확실성)
            ╲╱
            
타원의 축 = 고유벡터 방향
타원의 크기 = √고유값 (표준편차)
```

#### 고유값 분해의 핵심 정리

| 개념 | 의미 | SLAM 활용 |
|------|------|----------|
| **고유벡터** | 변환 후에도 방향 유지 | 불확실성의 주축 방향 |
| **고유값** | 그 방향의 스케일 | 그 방향의 분산(불확실성 크기) |
| **대칭 행렬** | 고유벡터가 직교 | 공분산 행렬은 대칭 |
| **양의 고유값** | 분산은 항상 양수 | 양정치 행렬 (positive definite) |

#### 고유값과 고유벡터 직접 계산하기 (수학적 풀이)

NumPy의 `np.linalg.eig()`가 내부적으로 어떻게 계산하는지, 손으로 직접 풀어봅시다.

##### 핵심 아이디어

고유값 방정식 **A·v = λ·v**를 정리하면:

```
A·v - λ·v = 0
(A - λI)·v = 0
```

**v ≠ 0** (영벡터가 아닌) 해가 존재하려면, (A - λI)가 **역행렬이 없어야** 합니다.

**왜 역행렬이 없어야 하는가?**

*Case 1: 역행렬이 있다면?*
```
(A - λI)·v = 0

양변에 (A - λI)⁻¹ 곱하면:
(A - λI)⁻¹ · (A - λI) · v = (A - λI)⁻¹ · 0
                    I · v = 0
                        v = 0   ← 영벡터만 해! (고유벡터 ❌)
```

*Case 2: 역행렬이 없다면?*
- 방정식이 무한히 많은 해를 가짐
- v = 0 외에도 다른 해가 존재
- v ≠ 0인 **고유벡터 발견!** ✅

| det(A - λI) | 역행렬 | v ≠ 0 해 | 고유벡터 |
|-------------|--------|---------|---------|
| ≠ 0 | 있음 | 없음 | ❌ |
| **= 0** | **없음** | **있음** | ✅ |

따라서 역행렬이 없다 = **행렬식이 0**이므로:

```
det(A - λI) = 0   ← "특성 방정식(Characteristic Equation)"
```

##### 1단계: 고유값(λ) 계산

예제 행렬:
```
A = [4  2]
    [2  3]
```

**Step 1**: A - λI 계산
```
A - λI = [4-λ   2  ]
         [2     3-λ]
```

**Step 2**: 행렬식 = 0으로 설정
```
det(A - λI) = (4-λ)(3-λ) - (2)(2) = 0
            = 12 - 4λ - 3λ + λ² - 4
            = λ² - 7λ + 8 = 0
```

**Step 3**: 이차방정식 풀기 (근의 공식)
```
λ = (7 ± √(49-32)) / 2 = (7 ± √17) / 2

λ₁ ≈ 5.56
λ₂ ≈ 1.44
```

> [!TIP]
> **2×2 행렬 단축 공식**: λ² - trace(A)·λ + det(A) = 0
> - trace(A) = 대각합 = 4 + 3 = 7
> - det(A) = 4×3 - 2×2 = 8

##### 2단계: 고유벡터(v) 계산

각 고유값 λ에 대해 **(A - λI)·v = 0** 을 풀어 v를 구합니다.

**λ₁ ≈ 5.56에 대한 고유벡터:**

```
(A - 5.56I)·v = 0

[4-5.56    2   ] [x]   [0]
[2      3-5.56] [y] = [0]

[-1.56   2    ] [x]   [0]
[2      -2.56] [y] = [0]
```

첫 번째 행에서:
```
-1.56x + 2y = 0
y = 0.78x
```

x = 1로 두면, 고유벡터: **v₁ = [1, 0.78]** (또는 정규화하면 단위벡터)

**λ₂ ≈ 1.44에 대한 고유벡터:**

```
(A - 1.44I)·v = 0

[2.56    2   ] [x]   [0]
[2      1.56] [y] = [0]
```

첫 번째 행에서:
```
2.56x + 2y = 0
y = -1.28x
```

고유벡터: **v₂ = [1, -1.28]**

##### Python으로 손계산 결과 검증

```python
import numpy as np

A = np.array([[4, 2], [2, 3]])

# NumPy로 고유값 분해
eigenvalues, eigenvectors = np.linalg.eig(A)

print("고유값:", eigenvalues)
# [5.56155281, 1.43844719] ← 손계산과 일치!

print("고유벡터 (각 열이 하나):")
print(eigenvectors)

# 검증: A @ v = λ * v
v1 = eigenvectors[:, 0]
lambda1 = eigenvalues[0]
print("A @ v1 =", A @ v1)
print("λ1 * v1 =", lambda1 * v1)
print("일치?:", np.allclose(A @ v1, lambda1 * v1))  # True
```

##### 손계산 요약 (2×2 행렬)

| 단계 | 작업 | 공식 |
|------|------|------|
| 1 | 특성방정식 세우기 | det(A - λI) = 0 |
| 2 | 고유값 구하기 | λ² - trace(A)·λ + det(A) = 0 풀기 |
| 3 | 고유벡터 구하기 | 각 λ에 대해 (A - λI)v = 0 풀기 |
| 4 | (선택) 정규화 | v를 단위벡터로 만들기: v/||v|| |

> [!NOTE]
> **3×3 이상 행렬**: 특성방정식이 3차 이상이 되어 손계산이 복잡해집니다. 
> 실무에서는 NumPy나 Eigen 라이브러리의 수치해법을 사용합니다.

### 4. 행렬식 (Determinant)

```python
A = np.array([[3, 1], [2, 4]])
det_A = np.linalg.det(A)
```

**기하학적 의미**:
- 2D: 두 벡터가 이루는 **평행사변형의 면적** 변화율
- 3D: 세 벡터가 이루는 **평행육면체의 부피** 변화율

---

## 🔄 회전 행렬 (Rotation Matrix) - 기초부터 이해하기

### 회전이란 무엇인가?

**회전**은 물체의 **위치는 그대로** 두고 **방향만 바꾸는** 변환입니다.

예를 들어:
- 시계 바늘이 원점(중심)을 기준으로 도는 것
- 로봇이 제자리에서 방향을 바꾸는 것
- 카메라가 고정된 채로 다른 방향을 바라보는 것

### 2D에서 점을 회전시키기

점 (1, 0)을 원점 기준으로 **θ도** 회전시키면 어디로 갈까요?

```
       y
       ↑
       |    ● (cos θ, sin θ) ← 회전 후
       |   /
       |  / θ
       | /
-------●------→ x
     (1,0) 원래 점
```

삼각함수의 정의에 따라:
- 회전 후 x좌표 = cos(θ)
- 회전 후 y좌표 = sin(θ)

### 회전 행렬의 유도

이제 **임의의 점 (x, y)** 를 θ만큼 회전시키면 어디로 갈까요?

**핵심 아이디어**: 점 (x, y)는 두 기저 벡터 (1,0)과 (0,1)의 조합으로 표현됩니다.

```
(x, y) = x·(1, 0) + y·(0, 1)
```

각 기저 벡터를 θ만큼 회전시키면:
- (1, 0) → (cos θ, sin θ)
- (0, 1) → (-sin θ, cos θ)

따라서 (x, y)를 회전하면:
```
x·(cos θ, sin θ) + y·(-sin θ, cos θ)
= (x·cos θ - y·sin θ, x·sin θ + y·cos θ)
```

이것을 행렬로 표현하면:

```
[x']   [cos θ  -sin θ] [x]
[y'] = [sin θ   cos θ] [y]
```

> [!NOTE]
> **회전 행렬 R(θ)**의 각 **열**은 회전된 기저 벡터입니다!
> - 1열: (1,0)이 회전 후 가는 곳
> - 2열: (0,1)이 회전 후 가는 곳

### 왜 "행렬"로 표현하는가?

1. **계산 편의성**: 행렬 곱셈 한 번으로 회전 완료
2. **회전 합성**: 연속 회전 = 행렬 곱셈
3. **역회전**: 역행렬 = 전치행렬 (계산 매우 간단)

```python
import numpy as np

# 30도 회전
theta = np.radians(30)  # 각도를 라디안으로

R = np.array([
    [np.cos(theta), -np.sin(theta)],
    [np.sin(theta),  np.cos(theta)]
])

# 점 (1, 0)을 회전
point = np.array([1, 0])
rotated = R @ point
print(f"(1, 0) → {rotated}")  # [0.866, 0.5]
```

### 3D 회전 행렬

3D에서는 **어떤 축 기준**으로 회전하는지가 중요합니다.

#### X축 회전 (Roll)

```
       y
       ↑
       |
       +---→ x
      /
     ↓ z

X축 기준으로 회전 = y-z 평면에서 회전
```

```python
def rotation_x(theta):
    c, s = np.cos(theta), np.sin(theta)
    return np.array([
        [1,  0,  0],   # x축은 변화 없음
        [0,  c, -s],   # y, z가 회전
        [0,  s,  c]
    ])
```

#### Y축 회전 (Pitch)

```python
def rotation_y(theta):
    c, s = np.cos(theta), np.sin(theta)
    return np.array([
        [ c,  0,  s],   # x, z가 회전
        [ 0,  1,  0],   # y축은 변화 없음
        [-s,  0,  c]
    ])
```

#### Z축 회전 (Yaw)

```python
def rotation_z(theta):
    c, s = np.cos(theta), np.sin(theta)
    return np.array([
        [c, -s,  0],   # x, y가 회전
        [s,  c,  0],
        [0,  0,  1]    # z축은 변화 없음
    ])
```

### 회전 행렬의 핵심 성질

| 성질 | 수식 | 의미 |
|------|------|------|
| **직교 행렬** | R^T R = I | 열벡터들이 서로 직교하고 크기가 1 |
| **det(R) = 1** | det(R) = +1 | 부피를 늘리거나 줄이지 않음, 반사 없음 |
| **역행렬 = 전치** | R^(-1) = R^T | 역회전 계산이 매우 빠름 |

```python
theta = np.radians(30)
R = np.array([
    [np.cos(theta), -np.sin(theta)],
    [np.sin(theta), np.cos(theta)]
])

# 성질 검증
print("R^T @ R =")
print(R.T @ R)  # 단위행렬

print(f"det(R) = {np.linalg.det(R):.4f}")  # 1.0

print("R^(-1) = R^T?:", np.allclose(np.linalg.inv(R), R.T))  # True
```

### 왜 직교 행렬인가? (길이 보존)

회전은 **길이를 바꾸지 않는** 변환입니다.

```
원래 벡터 v의 길이: ||v|| = √(v^T v)

회전 후 길이: ||Rv|| = √((Rv)^T (Rv))
            = √(v^T R^T R v)
            = √(v^T I v)     ← R^T R = I 이므로
            = √(v^T v)
            = ||v||           ← 원래 길이와 같음!
```

### 왜 det(R) = 1인가?

- **det > 0**: 좌표계 방향(오른손/왼손)을 유지
- **|det| = 1**: 부피를 변화시키지 않음
- 순수한 회전 = 방향 유지 + 크기 유지 → **det = 1**

> [!TIP]
> det = -1이면? → 회전 + 반사 (거울에 비친 것처럼)

### SLAM에서 회전 행렬이 중요한 이유

1. **카메라 자세 표현**: 카메라가 어느 방향을 보고 있는가
2. **좌표계 변환**: 월드 좌표계 ↔ 카메라 좌표계
3. **로봇 방향**: 로봇이 어느 방향을 향하고 있는가
4. **IMU 데이터 처리**: 센서 측정값을 월드 좌표로 변환

---

## 🔀 전치 행렬의 의미 - 단순한 행/열 교환 그 이상

### 전치(Transpose)란?

**전치**는 행렬의 행과 열을 바꾸는 연산입니다.

```
A = [1 2 3]      A^T = [1 4]
    [4 5 6]            [2 5]
                       [3 6]
```

수식으로는: `(A^T)_ij = A_ji`

하지만 **"행과 열을 바꾼다"는 것이 기하학적으로 무슨 의미일까요?**

---

### 1. 행렬의 본질: 선형 변환

행렬은 "벡터를 다른 벡터로 변환하는 함수"입니다.

```
A: R^n → R^m  (n차원 벡터를 m차원 벡터로 변환)
```

행렬 A의 **열벡터**들은 **입력 기저벡터가 어디로 가는지**를 나타냅니다:

```
A = [| |]     e1 = (1, 0) → a1으로 변환
    [a1 a2]   e2 = (0, 1) → a2로 변환
    [| |]
```

---

### 2. 전치의 핵심 의미: 내적 관점

전치 행렬의 가장 중요한 성질:

```
<Ax, y> = <x, A^T y>
```

**풀어서 설명하면:**
- `A`를 벡터 `x`에 적용한 후 `y`와 내적
- = `A^T`를 벡터 `y`에 적용한 후 `x`와 내적

> **A^T는 A의 "듀얼(dual)" 변환**입니다.
> 같은 변환을 **반대쪽에서 바라본 것**이죠.

#### 예시

```python
import numpy as np

A = np.array([[2, 1], [1, 3]])
x = np.array([1, 2])
y = np.array([3, 1])

# <Ax, y>
left = np.dot(A @ x, y)

# <x, A^T y>
right = np.dot(x, A.T @ y)

print(f"<Ax, y> = {left}")      # 19
print(f"<x, A^T y> = {right}")  # 19 (같다!)
```

---

### 3. 행과 열의 역할 교환

행렬에서 행과 열은 서로 다른 역할을 합니다:

```
      입력                    출력
        ↓                      ↓
A = [← r1 →]    =    [|  |]
    [← r2 →]         [c1 c2]
                      |  |
```

| 요소 | 역할 |
|------|------|
| **열벡터** | 입력 기저벡터의 **도착지** (어디로 변환되는가) |
| **행벡터** | 출력의 각 성분을 계산하는 **가중치** (어떻게 조합하는가) |

**전치하면 이 역할이 바뀝니다!**

```
원래 A: 열 = 도착지, 행 = 가중치
A^T:   열 = 가중치, 행 = 도착지
```

---

### 4. 좌표계 변환 관점

행렬이 좌표계 변환을 나타낼 때:

```
좌표계 A  ───M───►  좌표계 B
   점 p              점 p'

좌표계 B  ───M^T───►  좌표계 A  (방향이 반대!)
   벡터 v              벡터 v'
```

| 행렬 | 의미 |
|------|------|
| M | A 기준 좌표 → B 기준 좌표 |
| M^T | B 기준 좌표 → A 기준 좌표 (일반적으로 M^(-1)과 다름!) |

---

### 5. 일반 행렬에서: 전치 ≠ 역행렬

**일반적인 행렬**에서는 전치와 역행렬이 **완전히 다릅니다**:

```python
A = np.array([[1, 2], [3, 4]])

print("원래 행렬 A:")
print(A)

print("\n전치 행렬 A^T:")
print(A.T)          # [[1, 3], [2, 4]]

print("\n역행렬 A^(-1):")
print(np.linalg.inv(A))  # [[-2, 1], [1.5, -0.5]]

# 완전히 다르다!
```

---

### 6. 직교 행렬에서: 전치 = 역행렬 (특별한 경우!)

**직교 행렬**(회전 행렬 포함)에서만 전치와 역행렬이 같습니다:

```
R^T R = I  →  R^T = R^(-1)
```

**왜 같아지는가?**

직교 행렬의 열벡터들은:
- 길이가 1 (단위벡터)
- 서로 수직 (내적 = 0)

이런 **정규직교** 구조 덕분에 행과 열을 바꿔도 같은 성질이 유지됩니다.

```python
theta = np.radians(30)
R = np.array([
    [np.cos(theta), -np.sin(theta)],
    [np.sin(theta),  np.cos(theta)]
])

print("R^T @ R =")
print(R.T @ R)  # 단위행렬!

print("\nR^T == R^(-1)?:", np.allclose(R.T, np.linalg.inv(R)))  # True
```

---

### 7. 회전 행렬에서 전치의 기하학적 의미

**회전 행렬의 전치 = 역회전 (반대 방향 회전)**

```
R(θ): θ만큼 회전
R(θ)^T = R(-θ): -θ만큼 회전 (반대 방향!)
```

#### 2D 회전 예시

```
R(30°) = [cos30  -sin30]    R(30°)^T = [cos30   sin30]
         [sin30   cos30]               [-sin30  cos30]

                                     = R(-30°)
```

#### SLAM에서의 실용적 의미

```
월드 좌표계 ──R──► 카메라 좌표계
             ◄──R^T──
```

| 변환 | 의미 |
|------|------|
| R | 월드 → 카메라 (카메라가 바라보는 방향으로 변환) |
| R^T | 카메라 → 월드 (역행렬 계산 없이 빠르게!) |

---

### 전치 행렬 핵심 정리

| 관점 | 전치의 의미 |
|------|------------|
| **대수적** | 행 ↔ 열 교환 |
| **내적** | `<Ax, y> = <x, A^T y>` (듀얼 변환) |
| **역할** | 열벡터(도착지) ↔ 행벡터(가중치) 교환 |
| **좌표계** | 변환 방향의 "듀얼" |
| **직교/회전 행렬** | 역행렬과 동일, 역회전 |

> [!TIP]
> **계산 효율성**: 역행렬 계산은 O(n³) 복잡도지만, 전치는 O(1) 또는 O(n²) 복사만 필요합니다.
> 회전 행렬에서 R^T = R^(-1)이므로, 역변환이 매우 빠릅니다!

---

## 📊 공분산 행렬 (Covariance Matrix) - 기초부터 이해하기

### 분산(Variance)이란?

**분산**은 데이터가 평균에서 얼마나 **퍼져 있는지**를 나타내는 값입니다.

```python
import numpy as np

# 데이터
data = np.array([2, 4, 6, 8, 10])

# 평균
mean = np.mean(data)  # 6

# 분산 = (각 값 - 평균)²의 평균
variance = np.var(data)  # 8.0

# 표준편차 = √분산
std_dev = np.std(data)  # 2.83
```

```
분산이 작으면: 값들이 평균 근처에 모여있음 (정밀)
분산이 크면: 값들이 넓게 퍼져있음 (불확실)

      작은 분산              큰 분산
     ●●●●●●●●●             ●   ●  ●    ●
     |-----|               |-----------|
       좁음                     넓음
```

### 공분산(Covariance)이란?

**공분산**은 두 변수가 **함께 변하는 정도**를 나타냅니다.

```
양의 공분산: x 증가 → y도 증가 경향
음의 공분산: x 증가 → y는 감소 경향
공분산 ≈ 0: x와 y는 서로 관계 없음
```

```python
x = np.array([1, 2, 3, 4, 5])
y = np.array([2, 4, 5, 4, 6])

# 공분산 계산
cov_xy = np.cov(x, y)[0, 1]
# 양수면: x, y가 같은 방향으로 변함
```

```
양의 공분산         음의 공분산         공분산 ≈ 0
    ●                 ●                 ●  ●
   ●                   ●               ●   ●
  ●                     ●                ●  ●
 ●                       ●              ●  ●

x↑ → y↑            x↑ → y↓           관계 없음
```

### 공분산 "행렬"은 무엇인가?

2차원 데이터 (x, y)의 불확실성을 함께 표현하려면 **행렬**이 필요합니다:

```
공분산 행렬 P = [Var(x)    Cov(x,y)]
               [Cov(y,x)  Var(y)  ]

- 대각선: 각 축의 분산 (불확실성)
- 비대각선: 변수 간 상관관계
```

```python
# 공분산 행렬 예제
P = np.array([
    [0.04, 0.02],  # Var(x)=0.04, Cov(x,y)=0.02
    [0.02, 0.09]   # Cov(y,x)=0.02, Var(y)=0.09
])
```

> [!NOTE]
> **공분산 행렬의 특징**
> - **대칭 행렬**: Cov(x,y) = Cov(y,x) 이므로 Pᵀ = P
> - **양정치 행렬**: 모든 고유값이 양수 (분산은 항상 양수)

### 공분산 행렬의 각 원소 해석

```python
P = np.array([
    [0.04, 0.02],  
    [0.02, 0.09]   
])

# 대각 원소 → 분산 → 표준편차
std_x = np.sqrt(P[0, 0])  # √0.04 = 0.2
std_y = np.sqrt(P[1, 1])  # √0.09 = 0.3

print(f"x 표준편차: {std_x}")  # 0.2m 오차
print(f"y 표준편차: {std_y}")  # 0.3m 오차

# 비대각 원소 → 상관계수
correlation = P[0, 1] / (std_x * std_y)
print(f"상관계수: {correlation:.2f}")  # 0.33 (양의 상관)
```

### 불확실성 타원 시각화

공분산 행렬을 **고유값 분해**하면 불확실성의 **주축 방향과 크기**를 알 수 있습니다:

```python
P = np.array([
    [0.04, 0.02],
    [0.02, 0.09]
])

eigenvalues, eigenvectors = np.linalg.eig(P)

print("고유값 (주축 분산):", eigenvalues)
print("고유벡터 (주축 방향):")
print(eigenvectors)

# 불확실성 타원 반지름 = √고유값
radius_1 = np.sqrt(eigenvalues[0])
radius_2 = np.sqrt(eigenvalues[1])
```

```
불확실성 타원:

          y
          ↑
          |   ╱─────╲
          |  ╱       ╲  ← 고유벡터 2 방향
          | ╱    ●    ╲    반지름 = √λ₂
     ─────┼───────────────→ x
          | ╲         ╱
          |  ╲       ╱  ← 고유벡터 1 방향
          |   ╲─────╱     반지름 = √λ₁
          
- 타원 중심 = 추정 위치
- 타원 축 방향 = 고유벡터
- 타원 반지름 = √고유값 (표준편차)
```

### 공분산 행렬의 형태와 의미

```
1) 원형 (x, y 독립, 같은 크기 불확실성)
   P = [σ² 0 ]     ●
       [0  σ²]      ●

2) 축 방향 타원 (x, y 독립, 다른 크기)
   P = [σx² 0  ]    ●
       [0   σy²]      ●

3) 기울어진 타원 (x, y 상관관계 있음)
   P = [σx²  ρ  ]     ●
       [ρ    σy²]       ●
```

### NumPy로 공분산 행렬 계산하기

```python
# 측정 데이터에서 공분산 계산
np.random.seed(42)
n_samples = 100

# 상관관계 있는 2D 데이터 생성
mean = [5, 3]
cov_true = [[0.5, 0.3], [0.3, 0.8]]
data = np.random.multivariate_normal(mean, cov_true, n_samples)

# 데이터에서 공분산 추정
cov_estimated = np.cov(data.T)
print("추정된 공분산 행렬:")
print(cov_estimated)  # cov_true와 비슷해야 함
```

### SLAM에서 공분산 행렬의 역할

#### 1. 로봇 위치 추정의 불확실성

```python
# 로봇 상태: [x, y, θ]
state = np.array([5.0, 3.0, 0.5])  # 위치 (5,3), 방향 0.5rad

# 상태의 공분산 (3x3)
P = np.array([
    [0.04, 0.01, 0.00],  # x 분산, xy 공분산, xθ 공분산
    [0.01, 0.09, 0.02],  # yx 공분산, y 분산, yθ 공분산
    [0.00, 0.02, 0.01]   # θx 공분산, θy 공분산, θ 분산
])

# 해석: x는 ±0.2m, y는 ±0.3m, θ는 ±0.1rad 정도 불확실
```

#### 2. 칼만 필터에서의 공분산

```
예측 단계: P_pred = A·P·Aᵀ + Q
→ 불확실성 증가 (모션 노이즈 Q 추가)

업데이트 단계: P_new = (I - K·H)·P_pred
→ 불확실성 감소 (센서 관측으로 보정)
```

```python
# 칼만 필터의 세 가지 공분산
P = ...  # 상태 추정 불확실성 (시간에 따라 변화)
Q = np.diag([0.01, 0.01])  # 프로세스 노이즈 (모델 오차)
R = np.diag([0.1, 0.1])    # 측정 노이즈 (센서 오차)
```

#### 3. 센서 퓨전에서의 활용

```python
# GPS 공분산 (정확도 ±2m)
P_gps = np.diag([4.0, 4.0])  # 분산 = (표준편차)²

# IMU 공분산 (짧은 시간 정확, 장기 드리프트)
P_imu = np.diag([0.01, 0.01])  # 처음에는 작음

# 센서 퓨전: 두 정보를 공분산 기반으로 가중 평균
# 공분산이 작은(더 확실한) 센서에 더 높은 가중치
```

### 공분산 행렬 핵심 정리

| 개념 | 의미 | 위치 |
|------|------|------|
| **대각 원소** | 각 변수의 분산 | P[i,i] |
| **비대각 원소** | 변수 간 공분산 | P[i,j], i≠j |
| **표준편차** | √분산 = 불확실성 크기 | √P[i,i] |
| **고유값** | 주축 방향의 분산 | λ |
| **고유벡터** | 주축 방향 | v |

> [!TIP]
> **실무 팁**: 공분산 행렬이 잘 추정되었는지 확인하려면 실제 오차가 95% 확률로 2σ(표준편차의 2배) 이내에 들어오는지 체크하세요!

### 실무에서 공분산 파라미터 설정하기

공분산의 핵심 의미: **"이 값을 얼마나 믿을 수 있는가?"**

```
공분산 작음 = 분산 작음 = 불확실성 작음 = "이 값은 믿을 만해!"
공분산 큼   = 분산 큼   = 불확실성 큼   = "이 값은 좀 의심스러워..."
```

#### 센서 측정 노이즈 (R 행렬) 설정

```python
# GPS 공분산 - "GPS 측정을 얼마나 믿을까?"
R_gps = np.diag([4.0, 4.0])  # 분산 = (표준편차)²
# → 표준편차 = 2m, 즉 "GPS 측정은 ±2m 정도 오차 있어"

# LiDAR 공분산 - "라이다를 얼마나 믿을까?"
R_lidar = np.diag([0.01, 0.01])  
# → 표준편차 = 0.1m, 즉 "라이다는 ±10cm 정도 믿을 수 있어"
```

| R 값 | 의미 |
|------|------|
| R이 작을수록 | "이 센서를 많이 믿겠다" |
| R이 클수록 | "이 센서는 좀 부정확해" |

#### 프로세스 노이즈 (Q 행렬) 설정

```python
# 로봇 동작 모델 공분산 - "내 예측 모델을 얼마나 믿을까?"
Q = np.diag([0.1, 0.1, 0.05])  # [x, y, θ]
# → "로봇이 움직일 때 x,y는 ±0.3m, θ는 ±0.2rad 정도 오차 생겨"
```

| Q 값 | 의미 |
|------|------|
| Q가 작을수록 | "내 동작 모델은 정확해, 예측을 믿어" |
| Q가 클수록 | "동작 모델이 부정확해, 센서 관측을 더 믿어" |

#### 칼만 필터에서 Q vs R의 관계

```
            Q (프로세스 노이즈)
                 ↓
[현재 상태] → 예측 → [예측 상태] → 보정 → [최종 상태]
                          ↑
                     R (측정 노이즈)
```

| 상황 | Q vs R | 결과 |
|------|--------|------|
| Q 작고, R 큼 | 모델 신뢰 > 센서 신뢰 | 예측 결과를 더 믿음 |
| Q 크고, R 작음 | 모델 신뢰 < 센서 신뢰 | 센서 관측을 더 믿음 |
| 둘 다 작음 | 둘 다 신뢰 | 빠르게 수렴 |
| 둘 다 큼 | 둘 다 불신 | 불확실성 커짐, 수렴 느림 |

#### 잘못된 설정의 증상과 해결

```
Q가 너무 작으면:
└→ 센서 데이터 무시, 예측만 믿음 → 드리프트 발생!
   해결: Q를 키워서 센서 관측 반영 비율 높이기

Q가 너무 크면:
└→ 센서 노이즈에 민감 → 떨림 현상!
   해결: Q를 줄여서 예측 모델 신뢰도 높이기

R이 너무 작으면:
└→ 센서를 과신 → 노이즈가 그대로 결과에 반영
   해결: R을 키워서 센서 노이즈 감쇠

R이 너무 크면:
└→ 센서 무시 → 센서 있으나마나
   해결: R을 줄여서 센서 관측 활용
```

#### 실제 파라미터 설정 절차

```python
# 1단계: 센서 스펙시트에서 정확도 확인
#        예: GPS 정확도 ±2m → R = 2² = 4

# 2단계: 실험적으로 측정 (정지 상태에서 센서 분산 측정)
measurements = collect_sensor_data_when_stationary()
R_estimated = np.var(measurements, axis=0)

# 3단계: Q는 보통 R보다 작게 시작해서 조정
Q = R * 0.1  # 시작점, 드리프트 vs 떨림 보면서 조정

# 4단계: 실제 주행하면서 튜닝
# - 드리프트 발생 → Q 증가
# - 떨림 발생 → Q 감소 또는 R 증가
```

> [!IMPORTANT]
> **핵심 기억하기**: 공분산 = "나 이거 얼마나 믿어도 돼?"라는 질문에 대한 **수치화된 답변**입니다!

| 파라미터 | 의미 | 튜닝 방향 |
|---------|------|----------|
| **R** (측정 노이즈) | 센서 신뢰도 | 센서 스펙, 환경에 맞춰 설정 |
| **Q** (프로세스 노이즈) | 모델 신뢰도 | 드리프트 ↔ 떨림 트레이드오프 |
| **P** (상태 공분산) | 현재 추정 불확실성 | 자동 업데이트됨 (직접 설정 안 함) |



## 💻 실습 파일

이 폴더에 포함된 실습 파일:

| 파일 | 내용 |
|------|------|
| `linear_algebra_practice_basics.py` | 6파트 종합 실습 (행렬곱, 역행렬, 고유값, 행렬식, 회전행렬, 공분산) |
| `linear_algebra_practice_quiz.py` | 10문제 주관식 퀴즈 (문제/답안 분리) |

### 실행 방법

```bash
cd "Studies/Phase 1/week2"
python3 linear_algebra_practice_basics.py
python3 linear_algebra_practice_quiz.py
```

---

## 🎬 추천 자료

### 영상

| 영상 | 설명 |
|------|------|
| [3Blue1Brown - Matrix multiplication](https://youtu.be/XkY2DOUCWMU) | 행렬 곱셈 시각화 (복습) |
| [3Blue1Brown - Inverse matrices](https://youtu.be/uQhTuRlWMxw) | 역행렬의 의미 |
| [3Blue1Brown - Eigenvectors](https://youtu.be/PFDu9oVAE-g) | 고유벡터 직관 |

### 실습 도구

| 도구 | 용도 |
|------|------|
| [Desmos Matrix Calculator](https://www.desmos.com/matrix) | 온라인 행렬 계산기 |
| [GeoGebra](https://www.geogebra.org/classic) | 선형 변환 시각화 |

---

## ✅ 학습 완료 체크리스트

- [ ] NumPy로 행렬 곱셈, 역행렬, 고유값을 계산할 수 있다
- [ ] 행렬 곱셈이 "선형 변환의 합성"임을 설명할 수 있다
- [ ] 고유벡터가 "방향이 변하지 않는 벡터"임을 이해했다
- [ ] 2D 회전 행렬을 직접 유도할 수 있다
- [ ] 회전 행렬이 직교 행렬인 이유를 기하학적으로 설명할 수 있다
- [ ] det(R) = 1인 이유를 "크기 보존 + 방향 유지"로 설명할 수 있다
- [ ] 공분산 행렬의 대각 원소가 각 축의 분산임을 안다
- [ ] 공분산 행렬의 고유값 분해가 불확실성 타원과 연결됨을 이해했다

---

## 🔗 다음 단계

Week 2 완료 후 → **Week 3: SVD 집중**으로 이동
- SVD = 회전-스케일-회전 분해
- SLAM의 핵심 도구 (Essential Matrix, Homography 분해 등)
