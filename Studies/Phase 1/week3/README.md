# Week 3: SVD (íŠ¹ì´ê°’ ë¶„í•´) ì§‘ì¤‘

## ğŸ“Œ ê°œìš”

**SVD (Singular Value Decomposition, íŠ¹ì´ê°’ ë¶„í•´)** ëŠ” Visual SLAMì—ì„œ ê°€ì¥ ë¹ˆë²ˆí•˜ê²Œ ì‚¬ìš©ë˜ëŠ” í–‰ë ¬ ë¶„í•´ ê¸°ë²•ì…ë‹ˆë‹¤. Essential Matrixì—ì„œ ì¹´ë©”ë¼ í¬ì¦ˆ(R, t)ë¥¼ ì¶”ì¶œí•˜ê±°ë‚˜, Homography ë¶„í•´, PnP ë¬¸ì œ í•´ê²° ë“± ê±°ì˜ ëª¨ë“  ê¸°í•˜í•™ì  ë¬¸ì œì—ì„œ SVDê°€ ë“±ì¥í•©ë‹ˆë‹¤.

ì´ë²ˆ ì£¼ì—ëŠ” SVDì˜ **ê¸°í•˜í•™ì  ì§ê´€**ì„ ì–»ê³ , ì‹¤ì œ ì½”ë“œë¡œ êµ¬í˜„í•´ë³´ë©° SLAMì—ì„œì˜ í™œìš©ì„ ì´í•´í•©ë‹ˆë‹¤.

## ğŸ¯ í•™ìŠµ ëª©í‘œ

1. SVDì˜ ê¸°í•˜í•™ì  ì˜ë¯¸ ì´í•´ (íšŒì „ â†’ ìŠ¤ì¼€ì¼ â†’ íšŒì „)
2. íŠ¹ì´ê°’(Singular Value)ì˜ ì˜ë¯¸ íŒŒì•…
3. SVDë¥¼ ì´ìš©í•œ ìµœì†ŒììŠ¹ í•´ êµ¬í•˜ê¸°
4. NumPyë¡œ SVD ë¶„í•´ ì‹¤ìŠµ
5. SLAMì—ì„œ SVDê°€ ì‚¬ìš©ë˜ëŠ” í•µì‹¬ ì¥ë©´ ì´í•´

## ğŸ“š ì‚¬ì „ ì§€ì‹

- Week 1-2ì—ì„œ í•™ìŠµí•œ ì„ í˜•ëŒ€ìˆ˜ ê¸°ë³¸ ê°œë…
- í–‰ë ¬ ê³±ì…ˆ, ì—­í–‰ë ¬, ê³ ìœ ê°’ ë¶„í•´
- Python NumPy ê¸°ë³¸ ì‚¬ìš©ë²•

## â±ï¸ ì˜ˆìƒ í•™ìŠµ ì‹œê°„

| í•­ëª© | ì‹œê°„ |
|------|------|
| ì´ë¡  í•™ìŠµ | 2-3ì‹œê°„ |
| ì‹¤ìŠµ ì˜ˆì œ | 2-3ì‹œê°„ |
| SLAM ì‘ìš© ì´í•´ | 1-2ì‹œê°„ |
| **ì´ ì†Œìš”ì‹œê°„** | **5-8ì‹œê°„** |

---

## ğŸ“– ì´ë¡ : SVDë€ ë¬´ì—‡ì¸ê°€?

### ğŸ¤” ë¨¼ì €, ì™œ SVDê°€ í•„ìš”í•œê°€?

**ê³ ìœ ê°’ ë¶„í•´(Eigenvalue Decomposition)** ë¥¼ Week 2ì—ì„œ ë°°ì› ëŠ”ë°, ì´ê±´ **ì •ë°© í–‰ë ¬(nÃ—n)** ì—ë§Œ ì ìš©ë©ë‹ˆë‹¤.

ê·¸ëŸ°ë° í˜„ì‹¤ì—ì„œëŠ” **ì§ì‚¬ê° í–‰ë ¬(mÃ—n)** ì´ ë” ë§ìŠµë‹ˆë‹¤:
- ì´ë¯¸ì§€: 480Ã—640 (í–‰â‰ ì—´)
- 8ê°œì˜ ëŒ€ì‘ì ìœ¼ë¡œ Essential Matrix êµ¬í•  ë•Œ: 8Ã—9 í–‰ë ¬
- ì„¼ì„œ ë°ì´í„°: ì¸¡ì • íšŸìˆ˜ Ã— ë³€ìˆ˜ ê°œìˆ˜ (ëŒ€ë¶€ë¶„ ë‹¤ë¦„)

> [!IMPORTANT]
> **SVDëŠ” ì–´ë–¤ í¬ê¸°ì˜ í–‰ë ¬ì´ë“  ë¶„í•´í•  ìˆ˜ ìˆëŠ” "ë§ŒëŠ¥ ë„êµ¬"ì…ë‹ˆë‹¤!**

### ğŸ” "ë¶„í•´"ë€ ì •í™•íˆ ë¬´ì—‡ì¸ê°€?

**ë¶„í•´(Decomposition)** ë€ **ë³µì¡í•œ í–‰ë ¬ì„ ë” ë‹¨ìˆœí•˜ê³  ì˜ë¯¸ ìˆëŠ” ì¡°ê°ë“¤ë¡œ ìª¼ê°œëŠ” ê²ƒ**ì…ë‹ˆë‹¤.

#### ë¹„ìœ : í™”í•™ì˜ ì›ì†Œ ë¶„í•´
```
ë¬¼(Hâ‚‚O) â†’ ìˆ˜ì†Œ(Hâ‚‚) + ì‚°ì†Œ(O)
ë³µì¡í•œ ë¶„ì â†’ ê¸°ë³¸ ì›ì†Œë“¤ë¡œ ë¶„ë¦¬
```

#### SVD ë¶„í•´
```
í–‰ë ¬ A â†’ U (íšŒì „) + Î£ (ìŠ¤ì¼€ì¼) + Váµ€ (íšŒì „)
ë³µì¡í•œ ë³€í™˜ â†’ 3ê°€ì§€ ê¸°ë³¸ ë™ì‘ìœ¼ë¡œ ë¶„ë¦¬
```

### ğŸ“Š ë¶„í•´í•˜ë©´ ë¬´ì—‡ì„ ì–»ëŠ”ê°€?

```python
import numpy as np

# ì§ì‚¬ê° í–‰ë ¬ (3í–‰ Ã— 2ì—´)
A = np.array([
    [3, 2],
    [2, 3],
    [2, -2]
])

U, S, Vt = np.linalg.svd(A)
```

| ê²°ê³¼ë¬¼ | ì˜ë¯¸ | ì•Œ ìˆ˜ ìˆëŠ” ê²ƒ |
|--------|------|---------------|
| **U** (3Ã—3) | ì¶œë ¥ ê³µê°„ì˜ ì¶• ë°©í–¥ | ê²°ê³¼ê°€ ì–´ëŠ ë°©í–¥ìœ¼ë¡œ ë»—ì–´ìˆëŠ”ì§€ |
| **S** (íŠ¹ì´ê°’) | ê° ì¶•ì˜ ì¤‘ìš”ë„/í¬ê¸° | [5.0, 3.0] â†’ ì²« ë°©í–¥ì´ ë” ì¤‘ìš” |
| **Váµ€** (2Ã—2) | ì…ë ¥ ê³µê°„ì˜ ì¶• ë°©í–¥ | ì…ë ¥ ë°ì´í„°ì˜ ì£¼ìš” íŒ¨í„´ ë°©í–¥ |

### ğŸ¯ ë¶„í•´ ê²°ê³¼ë¡œ í•  ìˆ˜ ìˆëŠ” ê²ƒë“¤

#### 1. í–‰ë ¬ì˜ "ì¤‘ìš”ë„" íŒŒì•…

```
íŠ¹ì´ê°’ S = [100, 50, 0.001, 0.0002]
        â†“     â†“      â†“        â†“
      ë§¤ìš°   ì¤‘ìš”   ê±°ì˜     ë¬´ì‹œ
      ì¤‘ìš”          ë…¸ì´ì¦ˆ   ê°€ëŠ¥
```
â†’ í° íŠ¹ì´ê°’ = ì¤‘ìš”í•œ ì •ë³´, ì‘ì€ íŠ¹ì´ê°’ = ë…¸ì´ì¦ˆ

#### 2. ë­í¬(Rank) = ë…ë¦½ì ì¸ ì •ë³´ì˜ ê°œìˆ˜

```
S = [5.0, 3.0, 0.0]  â†’ ë­í¬ = 2 (0ì´ ì•„ë‹Œ íŠ¹ì´ê°’ ê°œìˆ˜)
                       â†’ ì‹¤ì œ ì •ë³´ëŠ” 2ì°¨ì›ì—ë§Œ ìˆìŒ!
```

#### 3. ì›ë˜ í–‰ë ¬ ë³µì› (U Ã— Î£ Ã— Váµ€ = A)

```python
# Î£ í–‰ë ¬ êµ¬ì„± (ëŒ€ê° í–‰ë ¬)
Sigma = np.zeros((3, 2))
Sigma[0, 0], Sigma[1, 1] = S[0], S[1]

# ë³µì›: A â‰ˆ U Ã— Î£ Ã— Váµ€
A_reconstructed = U @ Sigma @ Vt
print(np.allclose(A, A_reconstructed))  # True
```

#### 4. ì••ì¶• (ìƒìœ„ kê°œë§Œ ì‚¬ìš©)

```python
# ì²« ë²ˆì§¸ íŠ¹ì´ê°’ë§Œ ì‚¬ìš© (ê°€ì¥ ì¤‘ìš”í•œ ì •ë³´ë§Œ)
k = 1
A_compressed = U[:, :k] @ np.diag(S[:k]) @ Vt[:k, :]
# ì›ë³¸ì˜ í•µì‹¬ë§Œ ë‚¨ê¸´ "ìš”ì•½ë³¸"
```

### ğŸ› ï¸ ì‹¤ìš© ì˜ˆì‹œ: ì´ë¯¸ì§€ ì••ì¶•

```
1000Ã—1000 ì´ë¯¸ì§€ = 100ë§Œ í”½ì…€ ì €ì¥ í•„ìš”

SVD í›„ ìƒìœ„ 50ê°œ íŠ¹ì´ê°’ë§Œ ì‚¬ìš©:
- ì €ì¥ëŸ‰: 50 Ã— (1000 + 1 + 1000) = 10ë§Œ ê°œ
- ì••ì¶•ë¥ : 10% (ì›ë³¸ì˜ 1/10)
- í’ˆì§ˆ: ìœ¡ì•ˆìœ¼ë¡œ ê±°ì˜ ì°¨ì´ ì—†ìŒ!
```

### ğŸ”‘ SLAMì—ì„œ SVDê°€ í•„ìˆ˜ì¸ 4ê°€ì§€ ì´ìœ 

#### 1. Ax = 0 í˜•íƒœì˜ ë™ì°¨ ë°©ì •ì‹ í’€ê¸°
```
ì˜ˆ: 8-point ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ Essential Matrix ê³„ì‚°
    â†’ 8ê°œ ëŒ€ì‘ì  â†’ 8Ã—9 í–‰ë ¬ â†’ ì •ë°© í–‰ë ¬ì´ ì•„ë‹˜!
    â†’ SVDë¡œ Null space ì°¾ê¸° (ë§ˆì§€ë§‰ íŠ¹ì´ë²¡í„° = í•´)
```

#### 2. Essential Matrixì—ì„œ R, t ë¶„í•´
```
E = U Î£ Váµ€ë¡œ ë¶„í•´ â†’ íšŒì „ Rê³¼ ì´ë™ t ì¶”ì¶œ
â†’ ì¹´ë©”ë¼ê°€ ì–´ë””ë¡œ ì–¼ë§ˆë‚˜ ì›€ì§ì˜€ëŠ”ì§€ ì•Œ ìˆ˜ ìˆìŒ
```

#### 3. ìµœì†ŒììŠ¹ ë¬¸ì œ (ê³¼ê²°ì • ì‹œìŠ¤í…œ)
```
ì¸¡ì •ê°’ > ë¯¸ì§€ìˆ˜ â†’ ì •í™•í•œ í•´ ì—†ìŒ
SVDë¡œ ì˜¤ì°¨ë¥¼ ìµœì†Œí™”í•˜ëŠ” ìµœì í•´ ê³„ì‚°
ì˜ˆ: ì—¬ëŸ¬ ì ìœ¼ë¡œ ì§ì„ /í‰ë©´ í”¼íŒ…
```

#### 4. ë…¸ì´ì¦ˆ ì œê±° (ì €ë­í¬ ê·¼ì‚¬)
```
ì„¼ì„œ ë°ì´í„°ì—ì„œ ì¤‘ìš”í•œ íŠ¹ì´ê°’ë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ ì œê±°
â†’ ë…¸ì´ì¦ˆëŠ” ì‘ì€ íŠ¹ì´ê°’ì— ë¶„í¬ â†’ ìì—°ìŠ¤ëŸ½ê²Œ ì œê±°
```

> [!TIP]
> **í•œ ë¬¸ì¥ ìš”ì•½**: SVDëŠ” "ì–´ë–¤ í¬ê¸°ì˜ í–‰ë ¬ì´ë“  ë¶„í•´í•´ì„œ í•µì‹¬ ì •ë³´ë¥¼ ì¶”ì¶œ"í•  ìˆ˜ ìˆëŠ” ë§ŒëŠ¥ ë„êµ¬ì…ë‹ˆë‹¤. ê³ ìœ ê°’ ë¶„í•´ëŠ” ì •ë°© í–‰ë ¬ì—ë§Œ ì“¸ ìˆ˜ ìˆì§€ë§Œ, í˜„ì‹¤ì˜ ë°ì´í„°(ì´ë¯¸ì§€, ì„¼ì„œ, ëŒ€ì‘ì )ëŠ” ëŒ€ë¶€ë¶„ ì§ì‚¬ê° í–‰ë ¬ì´ë¼ì„œ SVDê°€ í•„ìˆ˜ì…ë‹ˆë‹¤.

---

### ğŸ’¡ `full_matrices` íŒŒë¼ë¯¸í„° ì´í•´

NumPyì˜ `np.linalg.svd()`ì—ì„œ `full_matrices` ì˜µì…˜ì€ Uì™€ V í–‰ë ¬ì˜ í¬ê¸°ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.

í–‰ë ¬ Aê°€ **mÃ—n** í¬ê¸°ì¼ ë•Œ (k = min(m, n)):

| `full_matrices` | U í¬ê¸° | S í¬ê¸° | Váµ€ í¬ê¸° | ìš©ë„ |
|-----------------|--------|--------|---------|------|
| `True` (ê¸°ë³¸ê°’) | mÃ—m | k | nÃ—n | Null space ë¶„ì„, ì™„ì „í•œ ì§êµ ê¸°ì € í•„ìš” ì‹œ |
| `False` | mÃ—k | k | kÃ—n | ë©”ëª¨ë¦¬/ê³„ì‚° íš¨ìœ¨, ëŒ€ë¶€ë¶„ì˜ ì‹¤ìš©ì  ì‚¬ìš© |

```python
import numpy as np

A = np.array([[1, 2], [3, 4], [5, 6]])  # 3Ã—2 í–‰ë ¬

# full_matrices=True (ì „ì²´ SVD)
U_full, S, Vt_full = np.linalg.svd(A, full_matrices=True)
print(f"U: {U_full.shape}, Váµ€: {Vt_full.shape}")  # U: (3,3), Váµ€: (2,2)

# full_matrices=False (ì¶•ì†Œ SVD)
U_reduced, S, Vt_reduced = np.linalg.svd(A, full_matrices=False)
print(f"U: {U_reduced.shape}, Váµ€: {Vt_reduced.shape}")  # U: (3,2), Váµ€: (2,2)
```

**SLAMì—ì„œì˜ ì„ íƒ ê¸°ì¤€:**
- **Homography/Essential Matrix ë¶„í•´** â†’ `True` (Null space ë²¡í„° í•„ìš”)
- **ìµœì†ŒììŠ¹ í•´, ì´ë¯¸ì§€ ì••ì¶•** â†’ `False` (íš¨ìœ¨ì„±)

---

### ğŸ“Œ í•µì‹¬ ì •ì˜

ì„ì˜ì˜ mÃ—n í–‰ë ¬ AëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë¶„í•´ë©ë‹ˆë‹¤:

```
A = U Î£ Váµ€
```

ì´ê²Œ ë¬´ìŠ¨ ëœ»ì¸ì§€ í•˜ë‚˜ì”© í’€ì–´ë´…ì‹œë‹¤.

---

### ğŸ§± ê° í–‰ë ¬ì˜ ì˜ë¯¸

í–‰ë ¬ Aê°€ **mÃ—n** í¬ê¸°ë¼ê³  í•˜ë©´:

| í–‰ë ¬ | í¬ê¸° | ì„±ì§ˆ | ë¹„ìœ  |
|------|------|------|------|
| **U** | mÃ—m | ì§êµ í–‰ë ¬ (ì—´ë²¡í„°ê°€ ì •ê·œì§êµ) | "ì¶œë ¥ ê³µê°„ì˜ ì¢Œí‘œì¶•" |
| **Î£** | mÃ—n | ëŒ€ê° í–‰ë ¬ (ëŒ€ê°ì„ ì—ë§Œ ê°’ ìˆìŒ) | "ê° ì¶•ìœ¼ë¡œ ì–¼ë§ˆë‚˜ ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸°" |
| **Váµ€** | nÃ—n | ì§êµ í–‰ë ¬ (í–‰ë²¡í„°ê°€ ì •ê·œì§êµ) | "ì…ë ¥ ê³µê°„ì˜ ì¢Œí‘œì¶•" |

```
ì˜ˆ: 3Ã—2 í–‰ë ¬ A

A = U    Ã—   Î£   Ã—  Váµ€
[3Ã—2] [3Ã—3] Ã— [3Ã—2] Ã— [2Ã—2]
```

---

### ğŸ“ Î£(íŠ¹ì´ê°’) í–‰ë ¬ì˜ í¬ê¸°ëŠ” ì–´ë–»ê²Œ ê²°ì •ë˜ëŠ”ê°€?

ì›ë³¸ í–‰ë ¬ Aê°€ **m Ã— n** í¬ê¸°ì¼ ë•Œ:

```
íŠ¹ì´ê°’ ê°œìˆ˜ = min(m, n)  â† í–‰ê³¼ ì—´ ì¤‘ ì‘ì€ ê°’
Î£ í–‰ë ¬ í¬ê¸° = m Ã— n      â† ì›ë³¸ê³¼ ë™ì¼!
```

#### ì™œ ì´ë ‡ê²Œ ë ê¹Œ?

```
A     =    U    Ã—    Î£    Ã—    Váµ€
(mÃ—n)   (mÃ—m)     (mÃ—n)     (nÃ—n)
```

**í–‰ë ¬ ê³±ì…ˆì´ ê°€ëŠ¥í•˜ë ¤ë©´:**
- U(mÃ—m) Ã— Î£ â†’ Î£ê°€ **mê°œ í–‰** í•„ìš”
- Î£ Ã— Váµ€(nÃ—n) â†’ Î£ê°€ **nê°œ ì—´** í•„ìš”
- ë”°ë¼ì„œ Î£ëŠ” **mÃ—n** í¬ê¸°!

**ëŒ€ê°ì„ ì—ë§Œ ê°’ì´ ìˆìœ¼ë¯€ë¡œ:**
- ëŒ€ê°ì„  ê¸¸ì´ = min(m, n)
- íŠ¹ì´ê°’ ê°œìˆ˜ = min(m, n)

#### ì˜ˆì‹œ

| ì›ë³¸ A | Î£ í¬ê¸° | íŠ¹ì´ê°’ ê°œìˆ˜ | êµ¬ì¡° |
|--------|--------|-------------|------|
| 3Ã—2 | 3Ã—2 | 2ê°œ | `[Ïƒâ‚ 0; 0 Ïƒâ‚‚; 0 0]` (ë‚¨ëŠ” í–‰ì€ 0) |
| 2Ã—4 | 2Ã—4 | 2ê°œ | `[Ïƒâ‚ 0 0 0; 0 Ïƒâ‚‚ 0 0]` (ë‚¨ëŠ” ì—´ì€ 0) |
| 3Ã—3 | 3Ã—3 | 3ê°œ | `[Ïƒâ‚ 0 0; 0 Ïƒâ‚‚ 0; 0 0 Ïƒâ‚ƒ]` |

> [!WARNING]
> **NumPy ì£¼ì˜ì‚¬í•­**: `np.linalg.svd()`ëŠ” Î£ í–‰ë ¬ì´ ì•„ë‹Œ **íŠ¹ì´ê°’ 1D ë°°ì—´**ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
> ```python
> U, S, Vt = np.linalg.svd(A)
> print(S.shape)  # (2,) â† 1D ë°°ì—´!
> 
> # Î£ í–‰ë ¬ì„ ì§ì ‘ ë§Œë“¤ë ¤ë©´:
> Sigma = np.zeros((m, n))
> Sigma[:len(S), :len(S)] = np.diag(S)
> ```

---

### ğŸ¨ ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°: "í¬í† ìƒµ ë³€í™˜"

ì´ë¯¸ì§€ë¥¼ í¸ì§‘í•  ë•Œ ë³€í™˜ì„ ìƒê°í•´ë³´ì„¸ìš”:

```
ì›ë³¸ ì´ë¯¸ì§€ â†’ [íšŒì „] â†’ [ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸°] â†’ [ë˜ íšŒì „] â†’ ê²°ê³¼ ì´ë¯¸ì§€
```

**SVDê°€ ë§í•˜ëŠ” ê²ƒ:**
> "ì–´ë–¤ ë³µì¡í•œ ë³€í™˜ì´ë“ , ì‚¬ì‹¤ì€ **íšŒì „ â†’ ìŠ¤ì¼€ì¼ â†’ íšŒì „** 3ë‹¨ê³„ë¡œ ë¶„í•´í•  ìˆ˜ ìˆë‹¤!"

```
ì…ë ¥ ë²¡í„° x
    â†“
   Váµ€ (ì²« ë²ˆì§¸ íšŒì „: ì…ë ¥ì„ ìƒˆë¡œìš´ ì¢Œí‘œì¶•ìœ¼ë¡œ ì •ë ¬)
    â†“
    Î£ (ìŠ¤ì¼€ì¼: ê° ì¶• ë°©í–¥ìœ¼ë¡œ ëŠ˜ì´ê¸°/ì¤„ì´ê¸°)
    â†“
    U (ë‘ ë²ˆì§¸ íšŒì „: ì¶œë ¥ ë°©í–¥ìœ¼ë¡œ ëŒë¦¬ê¸°)
    â†“
ê²°ê³¼ ë²¡í„° y = Ax
```

---

### ğŸ“ ì•„ì£¼ ê°„ë‹¨í•œ ì˜ˆì œ

**2Ã—2 ëŒ€ê° í–‰ë ¬ì„ SVD í•´ë´…ì‹œë‹¤:**

```python
import numpy as np

A = np.array([
    [3, 0],
    [0, 2]
])

U, S, Vt = np.linalg.svd(A)

print("U =\n", U)    # ë‹¨ìœ„í–‰ë ¬ (íšŒì „ ì—†ìŒ)
print("S =", S)      # [3, 2] - íŠ¹ì´ê°’ë“¤
print("Vt =\n", Vt)  # ë‹¨ìœ„í–‰ë ¬ (íšŒì „ ì—†ìŒ)
```

**í•´ì„:**
- ì´ í–‰ë ¬ AëŠ” ì´ë¯¸ **ëŒ€ê° í–‰ë ¬**ì´ë¼ì„œ
- íšŒì „ ì—†ìŒ (Uì™€ Vtê°€ ë‹¨ìœ„í–‰ë ¬)
- xì¶• ë°©í–¥ìœ¼ë¡œ 3ë°°, yì¶• ë°©í–¥ìœ¼ë¡œ 2ë°° ìŠ¤ì¼€ì¼

---

### ğŸ”„ "íšŒì „ì´ ìˆë‹¤/ì—†ë‹¤"ì˜ ì˜ë¯¸ ìƒì„¸ ì„¤ëª…

SVDëŠ” í–‰ë ¬ Aë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ë¶„í•´í•©ë‹ˆë‹¤:

**A = U Ã— Î£ Ã— Váµ€**

ì—¬ê¸°ì„œ:
- **U**: ì¶œë ¥ ê³µê°„ì—ì„œì˜ íšŒì „ (ì™¼ìª½ íŠ¹ì´ë²¡í„°ë“¤)
- **Î£**: ê° ì¶• ë°©í–¥ìœ¼ë¡œì˜ ìŠ¤ì¼€ì¼ë§ (ëŠ˜ë¦¬ê¸°/ì¤„ì´ê¸°)
- **Váµ€**: ì…ë ¥ ê³µê°„ì—ì„œì˜ íšŒì „ (ì˜¤ë¥¸ìª½ íŠ¹ì´ë²¡í„°ë“¤)

#### ğŸ“ ëŒ€ê° í–‰ë ¬: íšŒì „ ì—†ìŒ (U, Váµ€ = ë‹¨ìœ„í–‰ë ¬)

```python
diagonal_A = np.array([
    [3, 0],
    [0, 2]
])
```

ì´ í–‰ë ¬ì˜ SVD ê²°ê³¼:
- **U â‰ˆ ë‹¨ìœ„í–‰ë ¬ (Identity Matrix)**
- **Váµ€ â‰ˆ ë‹¨ìœ„í–‰ë ¬ (Identity Matrix)**

**ì™œ "íšŒì „ ì—†ìŒ"ì¸ê°€?**

ë‹¨ìœ„í–‰ë ¬ì€ **ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠëŠ” ë³€í™˜**ì…ë‹ˆë‹¤:
```
[1, 0]     íšŒì „ê° = 0Â°
[0, 1]
```

ëŒ€ê° í–‰ë ¬ `[[3, 0], [0, 2]]`ê°€ ë²¡í„°ì— í•˜ëŠ” ì¼:
1. xì¶• ë°©í–¥ìœ¼ë¡œ **3ë°°** ëŠ˜ë¦¼
2. yì¶• ë°©í–¥ìœ¼ë¡œ **2ë°°** ëŠ˜ë¦¼
3. **íšŒì „ì€ ì „í˜€ ì—†ìŒ!**

```
ì›ë˜ ë²¡í„° (1,1) â†’ ë³€í™˜ í›„ (3,2)
     â†‘                    â†‘
   ì •ì‚¬ê°í˜•            ì§ì‚¬ê°í˜• (ì¶• ë°©í–¥ ê·¸ëŒ€ë¡œ)
```

#### ğŸ”„ ë¹„ëŒ€ê° í–‰ë ¬: íšŒì „ ìˆìŒ (U, Váµ€ â‰  ë‹¨ìœ„í–‰ë ¬)

```python
rotation_scale_A = np.array([
    [2, 1],
    [1, 2]
])
```

ì´ í–‰ë ¬ì˜ SVD ê²°ê³¼:
- **U â‰  ë‹¨ìœ„í–‰ë ¬** (ì•½ 45Â° íšŒì „ í¬í•¨)
- **Váµ€ â‰  ë‹¨ìœ„í–‰ë ¬** (ì•½ 45Â° íšŒì „ í¬í•¨)

**ì™œ "íšŒì „ ìˆìŒ"ì¸ê°€?**

ë¹„ëŒ€ê° ì›ì†Œ `1`ì´ ìˆë‹¤ëŠ” ê²ƒì€ **xì¶•ê³¼ yì¶•ì´ ì„œë¡œ ì„ì¸ë‹¤**ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.

```
ì›ë˜ ë²¡í„° (1,0) â†’ ë³€í™˜ í›„ (2,1)
     â†‘                    â†‘
   xì¶• ë°©í–¥            ëŒ€ê°ì„  ë°©í–¥ìœ¼ë¡œ ê¸°ìš¸ì–´ì§!
```

**ë³€í™˜ ê³¼ì •ì„ ë‹¨ê³„ë³„ë¡œ ë³´ë©´:**

1. **Váµ€ íšŒì „**: ì…ë ¥ ë²¡í„°ë¥¼ ë¨¼ì € íšŒì „ (ì•½ 45Â°)
2. **Î£ ìŠ¤ì¼€ì¼**: ì£¼ì¶• ë°©í–¥ìœ¼ë¡œ ëŠ˜ë¦¬ê¸° (íŠ¹ì´ê°’ 3ê³¼ 1)
3. **U íšŒì „**: ìµœì¢… ì¶œë ¥ì„ ë‹¤ì‹œ íšŒì „ (ì•½ 45Â°)

#### ğŸ“Š ì‹œê°ì  ë¹„êµ

| | ëŒ€ê° í–‰ë ¬ (íšŒì „ ì—†ìŒ) | ë¹„ëŒ€ê° í–‰ë ¬ (íšŒì „ ìˆìŒ) |
|---|---|---|
| **ì›** | â†’ **íƒ€ì›** (ì¶• ì •ë ¬) | â†’ **íƒ€ì›** (ê¸°ìš¸ì–´ì§) |
| **U, Váµ€** | ë‹¨ìœ„í–‰ë ¬ | ë‹¨ìœ„í–‰ë ¬ ì•„ë‹˜ |
| **ì˜ë¯¸** | ìˆœìˆ˜í•œ ìŠ¤ì¼€ì¼ë§ | íšŒì „ + ìŠ¤ì¼€ì¼ë§ |

> [!TIP]
> **í•µì‹¬ í¬ì¸íŠ¸:**
> - **U, Váµ€ê°€ ë‹¨ìœ„í–‰ë ¬** â†’ ìˆœìˆ˜í•œ ìŠ¤ì¼€ì¼ ë³€í™˜ (ë°©í–¥ ìœ ì§€)
> - **U, Váµ€ê°€ ë‹¨ìœ„í–‰ë ¬ì´ ì•„ë‹˜** â†’ íšŒì „ì´ í¬í•¨ëœ ë³€í™˜ (ë°©í–¥ ë³€ê²½)
>
> SLAMì—ì„œ ì´ê²ƒì´ ì¤‘ìš”í•œ ì´ìœ : ë¡œë´‡ì˜ ì›€ì§ì„ì„ **íšŒì „ ì„±ë¶„**ê³¼ **ì´ë™/ìŠ¤ì¼€ì¼ ì„±ë¶„**ìœ¼ë¡œ ë¶„ë¦¬í•´ì„œ ë¶„ì„í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤!

---

### ğŸ”„ ë” ë³µì¡í•œ ì˜ˆì œ (íšŒì „ì´ ìˆëŠ” ê²½ìš°)

```python
A = np.array([
    [2, 1],
    [1, 2]
])

U, S, Vt = np.linalg.svd(A)
# S = [3, 1] - íŠ¹ì´ê°’
```

**ì´ í–‰ë ¬ì€:**
1. ë¨¼ì € Váµ€ë¡œ 45ë„ ë§Œí¼ íšŒì „
2. í•œ ì¶•ì€ 3ë°°, ë‹¤ë¥¸ ì¶•ì€ 1ë°°ë¡œ ìŠ¤ì¼€ì¼
3. ë‹¤ì‹œ Uë¡œ íšŒì „

â†’ ê²°ê³¼ì ìœ¼ë¡œ íŠ¹ì • ë°©í–¥ìœ¼ë¡œ ëŠ˜ì–´ë‚œ ë³€í™˜!

---

### ğŸ“ ì§ì‚¬ê° í–‰ë ¬ ì˜ˆì œ (m â‰  n)

**SVDì˜ ê°•ì : ì •ë°© í–‰ë ¬ì´ ì•„ë‹ˆì–´ë„ ë¶„í•´ ê°€ëŠ¥!**

```python
# 3Ã—2 í–‰ë ¬ (í–‰ > ì—´)
A = np.array([
    [1, 2],
    [3, 4],
    [5, 6]
])

U, S, Vt = np.linalg.svd(A, full_matrices=True)

print(f"A í¬ê¸°: {A.shape}")      # (3, 2)
print(f"U í¬ê¸°: {U.shape}")      # (3, 3)
print(f"S (íŠ¹ì´ê°’): {S}")        # [9.53, 0.51]
print(f"Vt í¬ê¸°: {Vt.shape}")    # (2, 2)
```

**í•µì‹¬ í¬ì¸íŠ¸:**
```
A     =    U    Ã—    Î£    Ã—   Váµ€
(3Ã—2)   (3Ã—3)    (3Ã—2)    (2Ã—2)
```

- **Î£ (ì‹œê·¸ë§ˆ)** í–‰ë ¬ë„ ì§ì‚¬ê°í˜• (3Ã—2)ì´ ë¨!
- ëŒ€ê°ì„ ì—ë§Œ íŠ¹ì´ê°’ì´ ìˆê³ , ë‚˜ë¨¸ì§€ëŠ” 0

```
Î£ = [9.53   0  ]
    [  0   0.51]
    [  0    0  ]   â† í–‰ì´ ë” ë§ì•„ì„œ 0 í–‰ ì¶”ê°€
```

---

### ğŸ”€ ë°˜ëŒ€ ê²½ìš°: ì—´ì´ ë” ë§ì€ í–‰ë ¬ (m < n)

```python
# 2Ã—4 í–‰ë ¬ (ì—´ > í–‰)
B = np.array([
    [1, 2, 3, 4],
    [5, 6, 7, 8]
])

U, S, Vt = np.linalg.svd(B, full_matrices=True)

print(f"B í¬ê¸°: {B.shape}")      # (2, 4)
print(f"U í¬ê¸°: {U.shape}")      # (2, 2)
print(f"S (íŠ¹ì´ê°’): {S}")        # [14.27, 1.00]
print(f"Vt í¬ê¸°: {Vt.shape}")    # (4, 4)
```

**Î£ í–‰ë ¬ ëª¨ì–‘:**
```
Î£ = [14.27   0    0    0]
    [  0    1.00  0    0]
              â†‘
        ì—´ì´ ë” ë§ì•„ì„œ 0 ì—´ ì¶”ê°€
```

> [!TIP]
> **ë³µì› ê³µì‹ì„ ì´í•´í•˜ë©´ í¬ê¸°ê°€ ëª…í™•í•´ì§‘ë‹ˆë‹¤:**
> ```
> A(mÃ—n) = U(mÃ—m) Ã— Î£(mÃ—n) Ã— Váµ€(nÃ—n)
> ```
> í–‰ë ¬ ê³±ì…ˆì´ ê°€ëŠ¥í•˜ë ¤ë©´ ì´ í¬ê¸°ê°€ ë§ì•„ì•¼ í•©ë‹ˆë‹¤!

### ê¸°í•˜í•™ì  í•´ì„: íšŒì „-ìŠ¤ì¼€ì¼-íšŒì „

SVDì˜ í•µì‹¬ ì§ê´€ì€ **ëª¨ë“  ì„ í˜• ë³€í™˜ì€ ì„¸ ë‹¨ê³„ë¡œ ë¶„í•´ëœë‹¤**ëŠ” ê²ƒì…ë‹ˆë‹¤:

```
      Váµ€          Î£           U
[ì…ë ¥] â†’ [íšŒì „/ë°˜ì‚¬] â†’ [ì¶• ë°©í–¥ ìŠ¤ì¼€ì¼] â†’ [íšŒì „/ë°˜ì‚¬] â†’ [ì¶œë ¥]
```

1. **Váµ€ (ì²« ë²ˆì§¸ íšŒì „)**: ì…ë ¥ ê³µê°„ì—ì„œ ì¢Œí‘œì¶• ì •ë ¬
2. **Î£ (ìŠ¤ì¼€ì¼ë§)**: ê° ì¶• ë°©í–¥ìœ¼ë¡œ ëŠ˜ì´ê¸°/ì¤„ì´ê¸°
3. **U (ë‘ ë²ˆì§¸ íšŒì „)**: ì¶œë ¥ ê³µê°„ì—ì„œ ìµœì¢… ë°©í–¥ ì¡°ì •

#### â“ ì™œ ê³„ì‚° ìˆœì„œê°€ "ë°˜ëŒ€"ì¸ê°€?

ë§ì€ ì‚¬ëŒë“¤ì´ í˜¼ë€ìŠ¤ëŸ¬ì›Œí•˜ëŠ” ë¶€ë¶„ì…ë‹ˆë‹¤:

**A = U Ã— Î£ Ã— Váµ€** ì¸ë°, ì™œ ë²¡í„°ì— ì ìš©í•  ë•ŒëŠ” **Váµ€ â†’ Î£ â†’ U** ìˆœì„œë¡œ ê³„ì‚°í• ê¹Œìš”?

> [!IMPORTANT]
> **í–‰ë ¬ ê³±ì…ˆì˜ ê²°í•©ë²•ì¹™** ë•Œë¬¸ì…ë‹ˆë‹¤!

**ë²¡í„° xì— Aë¥¼ ì ìš©:**
```
y = A Ã— x = (U Ã— Î£ Ã— Váµ€) Ã— x
```

í–‰ë ¬ ê³±ì…ˆì€ **ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½ìœ¼ë¡œ** ê³„ì‚°ë©ë‹ˆë‹¤:
```
(U Ã— Î£ Ã— Váµ€) Ã— x = U Ã— (Î£ Ã— (Váµ€ Ã— x))
                    â†‘     â†‘      â†‘
                  3ë‹¨ê³„  2ë‹¨ê³„   1ë‹¨ê³„ (ë¨¼ì €!)
```

**ê³„ì‚° ìˆœì„œ:**
1. **1ë‹¨ê³„**: Váµ€ Ã— xë¥¼ ë¨¼ì € ê³„ì‚°
2. **2ë‹¨ê³„**: Î£ Ã— (1ë‹¨ê³„ ê²°ê³¼)ë¥¼ ê³„ì‚°
3. **3ë‹¨ê³„**: U Ã— (2ë‹¨ê³„ ê²°ê³¼)ë¥¼ ê³„ì‚°

**ë¹„ìœ  - í•¨ìˆ˜ í•©ì„±:**
```
f(g(h(x))) ë¥¼ ê³„ì‚°í•  ë•Œ:
1. h(x) ë¨¼ì €
2. g(ê²°ê³¼)
3. f(ê²°ê³¼)

ë§ˆì°¬ê°€ì§€ë¡œ (U Ã— Î£ Ã— Váµ€) Ã— x:
1. Váµ€ Ã— x ë¨¼ì €
2. Î£ Ã— (ê²°ê³¼)
3. U Ã— (ê²°ê³¼)
```

**ì‹¤ì œ ì˜ˆì‹œ:**
```
ì…ë ¥ ë²¡í„°: [0.707, 0.707]

1ë‹¨ê³„ - Váµ€ ì ìš©: [-1.0, 0.0]    â† ë¨¼ì € íšŒì „
2ë‹¨ê³„ - Î£ ì ìš©:  [-3.0, 0.0]    â† ìŠ¤ì¼€ì¼ë§
3ë‹¨ê³„ - U ì ìš©:  [2.12, 2.12]   â† ìµœì¢… íšŒì „
```

**ì •ë¦¬:**
- **A = U Ã— Î£ Ã— Váµ€**: í–‰ë ¬ë“¤ì˜ ê³±ì…ˆ "ìˆœì„œ" (ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½)
- **A Ã— x ê³„ì‚°**: ë²¡í„°ì— ì ìš© "ìˆœì„œ" (ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½)

ì´ê²ƒì€ "ìˆœì„œê°€ ë°˜ëŒ€"ê°€ ì•„ë‹ˆë¼, **í–‰ë ¬ í‘œê¸°ë²•ê³¼ ì‹¤ì œ ê³„ì‚° ë²•ì¹™ì˜ ì°¨ì´**ì…ë‹ˆë‹¤! âœ…

---

### âœï¸ íŠ¹ì´ê°’ì„ ì†ìœ¼ë¡œ ê³„ì‚°í•˜ëŠ” ë°©ë²•

ì»´í“¨í„°ì— ì˜ì¡´í•˜ì§€ ì•Šê³  ì†ìœ¼ë¡œ íŠ¹ì´ê°’ì„ ê³„ì‚°í•˜ëŠ” ìˆ˜í•™ì  ê³¼ì •ì„ ì´í•´í•˜ë©´ SVDì˜ ë³¸ì§ˆì„ ë” ê¹Šì´ ì´í•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### ğŸ“ ê³„ì‚° ê³µì‹

í–‰ë ¬ **A** (mÃ—n)ì˜ íŠ¹ì´ê°’ì„ êµ¬í•˜ëŠ” ë‹¨ê³„:

> [!IMPORTANT]
> **ì™œ A^T Aë¥¼ ì‚¬ìš©í•˜ëŠ”ê°€?**
> 
> mÃ—n ì§ì‚¬ê° í–‰ë ¬ AëŠ” **ì§ì ‘ ê³ ìœ ê°’ì„ êµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!** (ê³ ìœ ê°’ì€ ì •ë°© í–‰ë ¬ì—ë§Œ ì •ì˜ë¨)
> 
> ë”°ë¼ì„œ Aë¥¼ ì •ë°© í–‰ë ¬ë¡œ ë³€í™˜:
> - **A^T A**: nÃ—n ì •ë°© í–‰ë ¬ (n = ì—´ì˜ ê°œìˆ˜)
> - **A A^T**: mÃ—m ì •ë°© í–‰ë ¬ (m = í–‰ì˜ ê°œìˆ˜)
> 
> ì¼ë°˜ì ìœ¼ë¡œ **A^T A**ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤ (ë³´í†µ n â‰¤ mì´ë¯€ë¡œ ê³„ì‚°ì´ ë” íš¨ìœ¨ì ).

**1ë‹¨ê³„: A^T A ê³„ì‚°**
```
A^T Aë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤ (ê²°ê³¼ëŠ” nÃ—n ëŒ€ì¹­ í–‰ë ¬)
```

**ì˜ˆì‹œ:**
```
Aê°€ 3Ã—2 í–‰ë ¬ì´ë©´:
  A^T (2Ã—3) Ã— A (3Ã—2) = A^T A (2Ã—2) âœ… ì •ë°© í–‰ë ¬!
```

**2ë‹¨ê³„: ê³ ìœ ê°’(Î») êµ¬í•˜ê¸°**

íŠ¹ì„±ë°©ì •ì‹(characteristic equation)ì„ í’‰ë‹ˆë‹¤:
```
det(A^T A - Î»I) = 0
```
ì´ ë°©ì •ì‹ì˜ í•´ê°€ ê³ ìœ ê°’ Î»â‚, Î»â‚‚, ..., Î»â‚™ì…ë‹ˆë‹¤.

**3ë‹¨ê³„: íŠ¹ì´ê°’(Ïƒ) ê³„ì‚°**

íŠ¹ì´ê°’ì€ ê³ ìœ ê°’ì˜ ì œê³±ê·¼ì…ë‹ˆë‹¤:
```
Ïƒáµ¢ = âˆšÎ»áµ¢
```

ê´€ë¡€ì ìœ¼ë¡œ íŠ¹ì´ê°’ì€ **ë‚´ë¦¼ì°¨ìˆœ**ìœ¼ë¡œ ì •ë ¬í•©ë‹ˆë‹¤:
```
Ïƒâ‚ â‰¥ Ïƒâ‚‚ â‰¥ ... â‰¥ Ïƒâ‚™ â‰¥ 0
```

#### ğŸ’¡ í•µì‹¬ ì›ë¦¬

**ì™œ A^T Aì˜ ê³ ìœ ê°’ì„ ì‚¬ìš©í•˜ëŠ”ê°€?**

```
A = U Î£ Váµ€ë¼ë©´:

A^T A = (U Î£ Váµ€)^T (U Î£ Váµ€)
      = V Î£áµ€ Uáµ€ U Î£ Váµ€
      = V Î£áµ€ Î£ Váµ€     (âˆµ Uáµ€ U = I)
      = V diag(Ïƒâ‚Â², Ïƒâ‚‚Â², ..., Ïƒâ‚™Â²) Váµ€
```

ë”°ë¼ì„œ **A^T Aì˜ ê³ ìœ ê°’ = Ïƒáµ¢Â²** (íŠ¹ì´ê°’ì˜ ì œê³±)ì…ë‹ˆë‹¤!

#### ğŸ“ ì†ê³„ì‚° ì˜ˆì œ: 2Ã—2 í–‰ë ¬

í–‰ë ¬ **A = [[3, 0], [4, 5]]** ì˜ íŠ¹ì´ê°’ì„ êµ¬í•´ë´…ì‹œë‹¤.

**1ë‹¨ê³„: A^T A ê³„ì‚°**
```
A^T = [[3, 4],
       [0, 5]]

A^T A = [[3, 4],  Ã— [[3, 0],
         [0, 5]]     [4, 5]]

      = [[3Ã—3 + 4Ã—4,  3Ã—0 + 4Ã—5],
         [0Ã—3 + 5Ã—4,  0Ã—0 + 5Ã—5]]

      = [[25, 20],
         [20, 25]]
```

**2ë‹¨ê³„: íŠ¹ì„±ë°©ì •ì‹ í’€ê¸°**
```
det(A^T A - Î»I) = 0

det([[25-Î»,   20  ],
     [  20,  25-Î»]]) = 0

(25-Î»)(25-Î») - 20Ã—20 = 0
(25-Î»)Â² - 400 = 0
625 - 50Î» + Î»Â² - 400 = 0
Î»Â² - 50Î» + 225 = 0
```

ê·¼ì˜ ê³µì‹ ì‚¬ìš©:
```
Î» = (50 Â± âˆš(2500 - 900)) / 2
  = (50 Â± âˆš1600) / 2
  = (50 Â± 40) / 2

Î»â‚ = 45
Î»â‚‚ = 5
```

**3ë‹¨ê³„: íŠ¹ì´ê°’ ê³„ì‚°**
```
Ïƒâ‚ = âˆš45 = 3âˆš5 â‰ˆ 6.708
Ïƒâ‚‚ = âˆš5  â‰ˆ 2.236
```

**ìµœì¢… ê²°ê³¼:**
```
íŠ¹ì´ê°’: [6.708, 2.236]
```

#### ğŸ” ê²€ì¦ (NumPy ë¹„êµ)

```python
import numpy as np

A = np.array([[3, 0], [4, 5]])
U, S, Vt = np.linalg.svd(A)
print(f"S = {S}")  # [6.7082, 2.2361]
```

ì™„ë²½í•˜ê²Œ ì¼ì¹˜í•©ë‹ˆë‹¤! âœ…

#### ğŸ“ ì†ê³„ì‚° ì˜ˆì œ: mÃ—n ì§ì‚¬ê° í–‰ë ¬ (3Ã—2)

ì´ì œ **ì‹¤ì œ ì§ì‚¬ê° í–‰ë ¬**ì˜ íŠ¹ì´ê°’ì„ ê³„ì‚°í•´ë´…ì‹œë‹¤. í–‰ë ¬ **A = [[1, 0], [0, 1], [1, 1]]** ì˜ íŠ¹ì´ê°’ì„ êµ¬í•©ë‹ˆë‹¤.

**1ë‹¨ê³„: A^T A ê³„ì‚°**
```
A (3Ã—2):          A^T (2Ã—3):
[[1, 0],          [[1, 0, 1],
 [0, 1],           [0, 1, 1]]
 [1, 1]]

A^T A = [[1, 0, 1],  Ã— [[1, 0],
         [0, 1, 1]]     [0, 1],
                        [1, 1]]

      = [[1Ã—1 + 0Ã—0 + 1Ã—1,  1Ã—0 + 0Ã—1 + 1Ã—1],
         [0Ã—1 + 1Ã—0 + 1Ã—1,  0Ã—0 + 1Ã—1 + 1Ã—1]]

      = [[2, 1],
         [1, 2]]
```

**í•µì‹¬ í¬ì¸íŠ¸:** 
- ì›ë˜ AëŠ” 3Ã—2 (ì§ì‚¬ê°!)
- A^T AëŠ” 2Ã—2 (ì •ë°© í–‰ë ¬!) â†’ ê³ ìœ ê°’ ê³„ì‚° ê°€ëŠ¥!

**2ë‹¨ê³„: íŠ¹ì„±ë°©ì •ì‹ í’€ê¸°**
```
det(A^T A - Î»I) = 0

det([[2-Î»,   1  ],
     [ 1,   2-Î»]]) = 0

(2-Î»)(2-Î») - 1Ã—1 = 0
(2-Î»)Â² - 1 = 0
4 - 4Î» + Î»Â² - 1 = 0
Î»Â² - 4Î» + 3 = 0
```

ì¸ìˆ˜ë¶„í•´:
```
(Î» - 3)(Î» - 1) = 0

Î»â‚ = 3
Î»â‚‚ = 1
```

**3ë‹¨ê³„: íŠ¹ì´ê°’ ê³„ì‚°**
```
Ïƒâ‚ = âˆšÎ»â‚ = âˆš3 â‰ˆ 1.732
Ïƒâ‚‚ = âˆšÎ»â‚‚ = âˆš1 = 1.000
```

**ìµœì¢… ê²°ê³¼:**
```
3Ã—2 í–‰ë ¬ Aì˜ íŠ¹ì´ê°’: [1.732, 1.000]
```

**ê²€ì¦ (NumPy):**
```python
import numpy as np

A = np.array([[1, 0], [0, 1], [1, 1]])
U, S, Vt = np.linalg.svd(A)
print(f"S = {S}")  # [1.7321, 1.0000]
```

ì™„ë²½í•˜ê²Œ ì¼ì¹˜! âœ…

**ê¸°í•˜í•™ì  ì˜ë¯¸:**
- 3Ã—2 í–‰ë ¬ AëŠ” 2D ê³µê°„ì„ 3D ê³µê°„ìœ¼ë¡œ ë§¤í•‘
- íŠ¹ì´ê°’ [1.732, 1.000]ì€ ë‘ ì£¼ì¶• ë°©í–¥ì˜ ìŠ¤ì¼€ì¼ë§
- ì²« ë²ˆì§¸ ë°©í–¥ì€ ì•½ 1.73ë°°, ë‘ ë²ˆì§¸ ë°©í–¥ì€ 1ë°°ë¡œ ëŠ˜ì–´ë‚¨

---

#### ğŸ”„ ë¹„êµ: A^T A vs A A^T

ê°™ì€ í–‰ë ¬ Aì— ëŒ€í•´ **A A^T**ë¥¼ ì‚¬ìš©í•˜ë©´ ì–´ë–»ê²Œ ë ê¹Œìš”?

**A A^T ê³„ì‚°:**
```
A A^T = [[1, 0],  Ã— [[1, 0, 1],  = [[1, 0, 1],
         [0, 1],     [0, 1, 1]]     [0, 1, 1],
         [1, 1]]                     [1, 1, 2]]

      = [[1Ã—1 + 0Ã—0,  1Ã—0 + 0Ã—1,  1Ã—1 + 0Ã—1],
         [0Ã—1 + 1Ã—0,  0Ã—0 + 1Ã—1,  0Ã—1 + 1Ã—1],
         [1Ã—1 + 1Ã—0,  1Ã—0 + 1Ã—1,  1Ã—1 + 1Ã—1]]

      = [[1, 0, 1],
         [0, 1, 1],
         [1, 1, 2]]  (3Ã—3 í–‰ë ¬)
```

**íŠ¹ì„±ë°©ì •ì‹:** (3Ã—3ì´ë¯€ë¡œ 3ì°¨ ë°©ì •ì‹!)
```
det(A A^T - Î»I) = 0
â†’ Î»Â³ - 4Î»Â² + 3Î» = 0
â†’ Î»(Î»Â² - 4Î» + 3) = 0
â†’ Î»(Î» - 3)(Î» - 1) = 0

ê³ ìœ ê°’: Î»â‚ = 3, Î»â‚‚ = 1, Î»â‚ƒ = 0
```

**íŠ¹ì´ê°’:**
```
Ïƒâ‚ = âˆš3 â‰ˆ 1.732
Ïƒâ‚‚ = âˆš1 = 1.000
Ïƒâ‚ƒ = âˆš0 = 0.000
```

**ê²°ë¡ :**
- **0ì´ ì•„ë‹Œ íŠ¹ì´ê°’ì€ ë™ì¼**: [1.732, 1.000] âœ…
- A A^TëŠ” ì¶”ê°€ íŠ¹ì´ê°’ 0ì„ í¬í•¨ (í–‰ë ¬ì´ 3Ã—3ì´ì§€ë§Œ ë­í¬ëŠ” 2)
- **A^T Aê°€ ë” íš¨ìœ¨ì **: ë” ì‘ì€ í–‰ë ¬(2Ã—2 vs 3Ã—3)ë¡œ ë™ì¼í•œ ê²°ê³¼!

> [!TIP]
> **ì‹¤ì „ íŒ**: ì§ì‚¬ê° í–‰ë ¬ A (mÃ—n)ì˜ íŠ¹ì´ê°’ì„ êµ¬í•  ë•ŒëŠ” **min(m, n)** í¬ê¸°ì˜ ì •ë°© í–‰ë ¬ì„ ë§Œë“œëŠ” ê²ƒì´ íš¨ìœ¨ì ì…ë‹ˆë‹¤.
> - m > nì´ë©´ â†’ **A^T A** (nÃ—n) ì‚¬ìš© âœ…
> - m < nì´ë©´ â†’ **A A^T** (mÃ—m) ì‚¬ìš© âœ…

---

#### ğŸ“ 3Ã—3 ì´ìƒì˜ í–‰ë ¬

3Ã—3 ì´ìƒì˜ í–‰ë ¬ì—ì„œëŠ”:
- 3ì°¨ ë°©ì •ì‹ ì´ìƒì„ í’€ì–´ì•¼ í•©ë‹ˆë‹¤
- ê·¼ì˜ ê³µì‹ì´ ë³µì¡í•˜ê±°ë‚˜ ìˆ˜ì¹˜ì  ë°©ë²• í•„ìš”
- ì‹¤ì „ì—ì„œëŠ” ì»´í“¨í„° ì‚¬ìš©ì´ í•„ìˆ˜

í•˜ì§€ë§Œ **ì›ë¦¬ëŠ” ë™ì¼**í•©ë‹ˆë‹¤:
1. A^T A ê³„ì‚°
2. det(A^T A - Î»I) = 0 í’€ê¸°
3. Ïƒ = âˆšÎ»

> [!TIP]
> **SLAMì—ì„œì˜ ì˜ë¯¸**: ì†ê³„ì‚° ê³¼ì •ì„ ì´í•´í•˜ë©´, íŠ¹ì´ê°’ì´ í–‰ë ¬ì˜ "ì—ë„ˆì§€" ë˜ëŠ” "ì¤‘ìš”ë„"ë¥¼ ì–´ë–»ê²Œ ë‹´ê³  ìˆëŠ”ì§€ ì§ê´€ì ìœ¼ë¡œ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‘ì€ íŠ¹ì´ê°’(â‰ˆ0)ì€ ë…¸ì´ì¦ˆë‚˜ ë¶ˆí•„ìš”í•œ ì •ë³´ë¥¼ ë‚˜íƒ€ë‚´ë¯€ë¡œ, ì œê±°í•´ë„ ì›ë˜ ë°ì´í„°ì˜ ë³¸ì§ˆì€ ìœ ì§€ë©ë‹ˆë‹¤.

---

### ğŸ¯ íŠ¹ì´ê°’(Ïƒ)ì˜ ì˜ë¯¸

íŠ¹ì´ê°’ì€ **Î£ í–‰ë ¬ì˜ ëŒ€ê°ì„  ì›ì†Œ**ì…ë‹ˆë‹¤:

```
Î£ = [Ïƒâ‚  0   0 ]
    [0   Ïƒâ‚‚  0 ]
    [0   0   Ïƒâ‚ƒ]
```

| íŠ¹ì´ê°’ | ì˜ë¯¸ | ë¹„ìœ  |
|--------|------|------|
| **Ïƒâ‚ (ê°€ì¥ í¼)** | ê°€ì¥ ì¤‘ìš”í•œ ì •ë³´ ë°©í–¥ | "ë©”ì¸ ìŠ¤í† ë¦¬" |
| **Ïƒâ‚‚** | ë‘ ë²ˆì§¸ë¡œ ì¤‘ìš”í•œ ë°©í–¥ | "ì„œë¸Œ ìŠ¤í† ë¦¬" |
| **Ïƒâ‚– â‰ˆ 0** | ê±°ì˜ ë¬´ì‹œí•´ë„ ë˜ëŠ” ì •ë³´ | "ë…¸ì´ì¦ˆ" |
| **Ïƒ = 0** | ê·¸ ë°©í–¥ ì •ë³´ ì™„ì „íˆ ì—†ìŒ | "ë¹ˆ ê³µê°„" |

- **Ïƒâ‚ â‰¥ Ïƒâ‚‚ â‰¥ ... â‰¥ Ïƒáµ£ â‰¥ 0**: í•­ìƒ **ì–‘ìˆ˜**ì´ê³  **ë‚´ë¦¼ì°¨ìˆœ**
- **ë­í¬(rank)**: 0ì´ ì•„ë‹Œ íŠ¹ì´ê°’ì˜ ê°œìˆ˜ = í–‰ë ¬ì˜ ë­í¬

---

### ğŸ“ ë­í¬(Rank)ë¥¼ íŠ¹ì´ê°’ìœ¼ë¡œ ê³„ì‚°í•˜ê¸°

#### ìˆ˜í•™ì  ì›ë¦¬

í–‰ë ¬ì˜ **ë­í¬(rank)** ëŠ” **ì„ í˜•ë…ë¦½ì¸ í–‰(ë˜ëŠ” ì—´)ì˜ ê°œìˆ˜**ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. SVDë¥¼ ì‚¬ìš©í•˜ë©´ ì´ë¥¼ íŠ¹ì´ê°’ìœ¼ë¡œ ì‰½ê²Œ ê³„ì‚°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

> [!IMPORTANT]
> **í•µì‹¬ ì •ë¦¬**: í–‰ë ¬ì˜ ë­í¬ = 0ì´ ì•„ë‹Œ íŠ¹ì´ê°’ì˜ ê°œìˆ˜

#### ì™œ `np.sum(s > 1e-10)`ìœ¼ë¡œ ë­í¬ë¥¼ ê³„ì‚°í•˜ëŠ”ê°€?

**1ë‹¨ê³„: ì´ë¡ ì  ë°°ê²½**

```python
import numpy as np

# í’€ ë­í¬ í–‰ë ¬ (2Ã—2, ë­í¬ = 2)
full_rank = np.array([
    [1, 2],
    [3, 4]
])

_, s1, _ = np.linalg.svd(full_rank)
print(f"íŠ¹ì´ê°’: {s1}")  # [5.4650, 0.3650]
print(f"ë­í¬: {len(s1)}")  # 2 (ëª¨ë‘ 0ì´ ì•„ë‹˜)
```

```python
# ë­í¬ ë¶€ì¡± í–‰ë ¬ (2Ã—2, ë­í¬ = 1)
rank_deficient = np.array([
    [1, 2],
    [2, 4]  # ì²« ë²ˆì§¸ í–‰ì˜ 2ë°° â†’ ì„ í˜• ì¢…ì†
])

_, s2, _ = np.linalg.svd(rank_deficient)
print(f"íŠ¹ì´ê°’: {s2}")  # [5.4772, 0.0000]
print(f"ë­í¬: ?")  # ì´ë¡ ì ìœ¼ë¡œ 1ì´ì§€ë§Œ...
```

**2ë‹¨ê³„: ì‹¤ì œ ë¬¸ì œ - ìˆ˜ì¹˜ ì˜¤ì°¨(Numerical Error)**

ì»´í“¨í„°ëŠ” ë¶€ë™ì†Œìˆ˜ì  ì—°ì‚°ì—ì„œ ì™„ë²½í•œ 0ì„ ë§Œë“¤ì§€ ëª»í•©ë‹ˆë‹¤:

```python
print(s2)  # [5.47722558, 0.00000000]
# í•˜ì§€ë§Œ ì‹¤ì œë¡œëŠ”:
print(s2[1])  # 3.7747582837255322e-16 â† ì™„ë²½í•œ 0ì´ ì•„ë‹˜!
```

**ì™œ ì´ëŸ° ì¼ì´ ë°œìƒí•˜ëŠ”ê°€?**
- ë¶€ë™ì†Œìˆ˜ì  ì‚°ìˆ ì˜ ë°˜ì˜¬ë¦¼ ì˜¤ì°¨
- í–‰ë ¬ ê³±ì…ˆ/ë¶„í•´ ê³¼ì •ì˜ ëˆ„ì  ì˜¤ì°¨
- ì´ë¡ ì ìœ¼ë¡œ 0ì¸ ê°’ì´ **ë§¤ìš° ì‘ì€ ê°’**(~10â»Â¹â¶)ìœ¼ë¡œ ê³„ì‚°ë¨

**3ë‹¨ê³„: í—ˆìš© ì˜¤ì°¨(Tolerance) ì‚¬ìš©**

```python
# âŒ ì˜ëª»ëœ ë°©ë²•: ì •í™•íˆ 0ì¸ ê°œìˆ˜ ì„¸ê¸°
rank_wrong = np.sum(s2 == 0)  # 0 (ìˆ˜ì¹˜ ì˜¤ì°¨ ë•Œë¬¸ì—!)

# âœ… ì˜¬ë°”ë¥¸ ë°©ë²•: í—ˆìš© ì˜¤ì°¨ ì‚¬ìš©
tolerance = 1e-10  # 0.0000000001
rank_correct = np.sum(s2 > tolerance)  # 1 âœ…
```

#### í—ˆìš© ì˜¤ì°¨ ê°’ ì„ íƒ ê°€ì´ë“œ

| í—ˆìš© ì˜¤ì°¨ | ìš©ë„ | ì„¤ëª… |
|----------|------|------|
| `1e-10` | **ì¼ë°˜ì  ì‚¬ìš©** âœ… | ëŒ€ë¶€ë¶„ì˜ ê²½ìš°ì— ì í•© |
| `1e-15` | ê³ ì •ë°€ ê³„ì‚° | ë§¤ìš° ì •í™•í•œ ë°ì´í„°ì¼ ë•Œ |
| `1e-6` | ë…¸ì´ì¦ˆê°€ ë§ì€ ë°ì´í„° | ì„¼ì„œ ë°ì´í„°, ì‹¤í—˜ ì¸¡ì • |
| `rcond` parameter | NumPy ê¸°ë³¸ê°’ | í–‰ë ¬ í¬ê¸°ì— ë”°ë¼ ìë™ ì¡°ì • |

```python
# NumPyì˜ ìë™ í—ˆìš© ì˜¤ì°¨
# rcond = max(m, n) Ã— machine_epsilon
# machine_epsilon â‰ˆ 2.22e-16 (float64)
```

#### ì‹¤ì „ ì˜ˆì œ

**ì˜ˆì œ 1: ì™„ì „ ë­í¬ í–‰ë ¬**

```python
A = np.array([
    [1, 2],
    [3, 4]
])

U, s, Vt = np.linalg.svd(A)
print(f"íŠ¹ì´ê°’: {s}")  # [5.4650, 0.3650]
print(f"s > 1e-10: {s > 1e-10}")  # [True, True]
print(f"ë­í¬: {np.sum(s > 1e-10)}")  # 2
```

**ì˜ˆì œ 2: ë­í¬ ë¶€ì¡± í–‰ë ¬**

```python
B = np.array([
    [1, 2, 3],
    [2, 4, 6],
    [3, 6, 9]
])

U, s, Vt = np.linalg.svd(B)
print(f"íŠ¹ì´ê°’: {s}")  # [16.8481, 0.0000, 0.0000]
print(f"s > 1e-10: {s > 1e-10}")  # [True, False, False]
print(f"ë­í¬: {np.sum(s > 1e-10)}")  # 1
```

**ì˜ˆì œ 3: ì§ì‚¬ê° í–‰ë ¬**

```python
C = np.array([
    [1, 2],
    [3, 4],
    [5, 6]
])

U, s, Vt = np.linalg.svd(C)
print(f"íŠ¹ì´ê°’: {s}")  # [9.5256, 0.5143]
print(f"ë­í¬: {np.sum(s > 1e-10)}")  # 2 (min(3, 2) = 2)
```

#### ì½”ë“œ ë¶„ì„: `s > 1e-10`ì˜ ë™ì‘ ì›ë¦¬

```python
s = np.array([5.477, 0.365, 0.0000000001])

# 1ë‹¨ê³„: ë¶ˆë¦° ë°°ì—´ ìƒì„±
boolean_array = s > 1e-10
print(boolean_array)  # [True, True, False]

# 2ë‹¨ê³„: Trueë¥¼ 1ë¡œ, Falseë¥¼ 0ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ í•©ì‚°
rank = np.sum(boolean_array)
print(rank)  # 2

# NumPyì˜ sum()ì€ ë¶ˆë¦° ê°’ì„ ìë™ ë³€í™˜:
# True â†’ 1
# False â†’ 0
```

#### SLAMì—ì„œì˜ í™œìš©

**1. Essential Matrix ê²€ì¦**

```python
# Essential MatrixëŠ” ë­í¬ 2ì—¬ì•¼ í•¨
E = compute_essential_matrix(pts1, pts2)
U, s, Vt = np.linalg.svd(E)
rank = np.sum(s > 1e-10)

if rank != 2:
    print("ê²½ê³ : ìœ íš¨í•˜ì§€ ì•Šì€ Essential Matrix")
```

**2. Homography ìœ íš¨ì„± ê²€ì‚¬**

```python
# HomographyëŠ” í’€ ë­í¬(3)ì—¬ì•¼ í•¨
H = compute_homography(pts1, pts2)
U, s, Vt = np.linalg.svd(H)
rank = np.sum(s > 1e-6)  # ë…¸ì´ì¦ˆê°€ ë§ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë” í° í—ˆìš© ì˜¤ì°¨

if rank < 3:
    print("ê²½ê³ : Homography ê³„ì‚° ì‹¤íŒ¨ (ë­í¬ ë¶€ì¡±)")
```

**3. ë…¸ì´ì¦ˆ ì œê±° ë° ì •ê·œí™”**

```python
# ì‘ì€ íŠ¹ì´ê°’ì„ 0ìœ¼ë¡œ ê°•ì œí•˜ì—¬ ë…¸ì´ì¦ˆ ì œê±°
U, s, Vt = np.linalg.svd(noisy_matrix)

# ë­í¬ ê²°ì •
rank = np.sum(s > 1e-6)

# ì‘ì€ íŠ¹ì´ê°’ ì œê±°
s[rank:] = 0

# ê¹¨ë—í•œ í–‰ë ¬ ë³µì›
cleaned_matrix = U @ np.diag(s) @ Vt
```

---

### ğŸ”¢ ì¡°ê±´ìˆ˜(Condition Number) ì™„ë²½ ê°€ì´ë“œ

#### ğŸ“ ì •ì˜

**ì¡°ê±´ìˆ˜(Condition Number)** ëŠ” í–‰ë ¬ì˜ **ìˆ˜ì¹˜ì  ì•ˆì •ì„±**ì„ ë‚˜íƒ€ë‚´ëŠ” ì§€í‘œì…ë‹ˆë‹¤:

```
Îº(A) = Ïƒ_max / Ïƒ_min = (ê°€ì¥ í° íŠ¹ì´ê°’) / (ê°€ì¥ ì‘ì€ íŠ¹ì´ê°’)
```

ì—¬ê¸°ì„œ:
- **Ïƒ_max**: ê°€ì¥ í° íŠ¹ì´ê°’ (ê°€ì¥ ê°•í•œ ë°©í–¥)
- **Ïƒ_min**: ê°€ì¥ ì‘ì€ íŠ¹ì´ê°’ (ê°€ì¥ ì•½í•œ ë°©í–¥)
- **Îº(A)**: ì¡°ê±´ìˆ˜ (kappa, condition number)

#### ğŸ¤” ì™œ ì¤‘ìš”í•œê°€?

ì¡°ê±´ìˆ˜ëŠ” **"ì…ë ¥ì˜ ì‘ì€ ë³€í™”ê°€ ì¶œë ¥ì„ ì–¼ë§ˆë‚˜ í¬ê²Œ ë°”ê¾¸ëŠ”ê°€?"** ë¥¼ ì¸¡ì •í•©ë‹ˆë‹¤.

**ë¹„ìœ : ë‹¤ë¦¬ ê±´ë„ˆê¸°**

```
ì¡°ê±´ìˆ˜ê°€ ì‘ì€ í–‰ë ¬ (Îº â‰ˆ 1~100):
    ë„“ê³  íŠ¼íŠ¼í•œ ë‹¤ë¦¬ â†’ ì•ˆì „í•˜ê²Œ ê±´ë„ ìˆ˜ ìˆìŒ
    
ì¡°ê±´ìˆ˜ê°€ í° í–‰ë ¬ (Îº > 1000):
    ì¢ê³  í”ë“¤ë¦¬ëŠ” ë‹¤ë¦¬ â†’ ì‘ì€ ë°”ëŒì—ë„ ìœ„í—˜
    
ì¡°ê±´ìˆ˜ê°€ ë§¤ìš° í° í–‰ë ¬ (Îº â†’ âˆ):
    ê±°ì˜ ëŠì–´ì§„ ë‹¤ë¦¬ â†’ ê±´ë„ˆê¸° ë¶ˆê°€ëŠ¥ (singular)
```

#### ğŸ“Š ìˆ˜í•™ì  ì˜ë¯¸

ì„ í˜• ì‹œìŠ¤í…œ **Ax = b**ë¥¼ í’€ ë•Œ:

```
bì˜ ìƒëŒ€ ì˜¤ì°¨: Î´b / ||b||
   â†“
xì˜ ìƒëŒ€ ì˜¤ì°¨: â‰¤ Îº(A) Ã— (Î´b / ||b||)
   â†‘
ì…ë ¥ ì˜¤ì°¨ê°€ ìµœëŒ€ Îº(A)ë°°ë§Œí¼ ì¦í­ë¨!
```

**ì˜ˆì‹œ:**
```python
# ì¡°ê±´ìˆ˜ = 1000ì¸ í–‰ë ¬
# ì…ë ¥(b)ì— 0.1% ì˜¤ì°¨ â†’ ì¶œë ¥(x)ì— ìµœëŒ€ 100% ì˜¤ì°¨ ê°€ëŠ¥!
Îº = 1000
input_error = 0.001  # 0.1%
max_output_error = Îº * input_error  # 1.0 = 100%
```

#### ğŸ” ì¡°ê±´ìˆ˜ë¡œ í–‰ë ¬ ë¶„ë¥˜

| ì¡°ê±´ìˆ˜ ë²”ìœ„ | ë¶„ë¥˜ | ì˜ë¯¸ | ëŒ€ì²˜ ë°©ë²• |
|------------|------|------|----------|
| **Îº â‰ˆ 1** | ì™„ë²½í•œ ì¡°ê±´ | ì§êµ í–‰ë ¬ (U, V) | ë¬¸ì œ ì—†ìŒ âœ… |
| **Îº < 10** | ë§¤ìš° ì•ˆì • | ìˆ˜ì¹˜ì ìœ¼ë¡œ ì´ìƒì  | ì¼ë°˜ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš© |
| **Îº < 100** | ì•ˆì • | ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ì•ˆì „ | ì¼ë°˜ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš© |
| **Îº < 1,000** | ì•½ê°„ ë¶ˆì•ˆì • | ì£¼ì˜ í•„ìš” | ì •ê·œí™” ê³ ë ¤ |
| **Îº < 10â¶** | ë¶ˆì•ˆì • (ill-conditioned) | ë…¸ì´ì¦ˆì— ë§¤ìš° ë¯¼ê° | ì •ê·œí™” í•„ìˆ˜ âš ï¸ |
| **Îº > 10â¶** | ê±°ì˜ íŠ¹ì´ | ì‹¤ì§ˆì ìœ¼ë¡œ ë­í¬ ë¶€ì¡± | ë‹¤ë¥¸ ë°©ë²• ì‚¬ìš© ğŸš¨ |
| **Îº â†’ âˆ** | íŠ¹ì´ í–‰ë ¬ | ì—­í–‰ë ¬ ì—†ìŒ | ìœ ì‚¬ì—­í–‰ë ¬ ì‚¬ìš© |

#### ğŸ’» ì‹¤ì „ ì˜ˆì œ

**ì˜ˆì œ 1: ì•ˆì •ì ì¸ í–‰ë ¬ (ì‘ì€ ì¡°ê±´ìˆ˜)**

```python
import numpy as np

# ë‹¨ìœ„ í–‰ë ¬: ì™„ë²½í•œ ì¡°ê±´ (Îº = 1)
I = np.eye(3)
U, s, Vt = np.linalg.svd(I)
cond = s[0] / s[-1]
print(f"ì¡°ê±´ìˆ˜: {cond}")  # 1.0 âœ…
print("â†’ ê°€ì¥ ì•ˆì •ì ì¸ í–‰ë ¬!")
```

**ì˜ˆì œ 2: ì¤‘ê°„ ì¡°ê±´ìˆ˜**

```python
# ì¼ë°˜ì ì¸ í–‰ë ¬
A = np.array([
    [1, 2],
    [3, 4]
])

U, s, Vt = np.linalg.svd(A)
cond = s[0] / s[-1]
print(f"íŠ¹ì´ê°’: {s}")  # [5.4650, 0.3650]
print(f"ì¡°ê±´ìˆ˜: {cond:.2f}")  # 14.97
print("â†’ ì•ˆì •ì , ì¼ë°˜ ê³„ì‚° ê°€ëŠ¥ âœ…")
```

**ì˜ˆì œ 3: ë¶ˆì•ˆì •í•œ í–‰ë ¬ (í° ì¡°ê±´ìˆ˜)**

```python
# ê±°ì˜ ì„ í˜• ì¢…ì†ì¸ í–‰ë ¬
B = np.array([
    [1.0, 2.0],
    [1.0, 2.0001]  # ê±°ì˜ ê°™ì€ í–‰!
])

U, s, Vt = np.linalg.svd(B)
cond = s[0] / s[-1]
print(f"íŠ¹ì´ê°’: {s}")  # [3.1623, 0.0001]
print(f"ì¡°ê±´ìˆ˜: {cond:.0f}")  # 31,623 âš ï¸
print("â†’ ë§¤ìš° ë¶ˆì•ˆì •! ë…¸ì´ì¦ˆì— ë¯¼ê°")
```

**ì˜ˆì œ 4: íŠ¹ì´ í–‰ë ¬ (ë¬´í•œëŒ€ ì¡°ê±´ìˆ˜)**

```python
# ì™„ì „íˆ ì„ í˜• ì¢…ì†
C = np.array([
    [1, 2],
    [2, 4]  # ì²« í–‰ì˜ 2ë°°
])

U, s, Vt = np.linalg.svd(C)
print(f"íŠ¹ì´ê°’: {s}")  # [5.4772, 0.0000]

# 0ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì¡°ê±´ìˆ˜ = ë¬´í•œëŒ€
if s[-1] < 1e-10:
    print("ì¡°ê±´ìˆ˜: âˆ (íŠ¹ì´ í–‰ë ¬) ğŸš¨")
else:
    cond = s[0] / s[-1]
    print(f"ì¡°ê±´ìˆ˜: {cond}")
```

#### ğŸ”¬ ì¡°ê±´ìˆ˜ì™€ ë…¸ì´ì¦ˆ ì¦í­

**ì‹¤í—˜: ë…¸ì´ì¦ˆê°€ ì–¼ë§ˆë‚˜ ì¦í­ë˜ëŠ”ê°€?**

```python
import numpy as np

# ì¡°ê±´ìˆ˜ê°€ ë‹¤ë¥¸ ë‘ í–‰ë ¬
A_good = np.array([[1, 0], [0, 1]])  # ì¡°ê±´ìˆ˜ = 1
A_bad = np.array([[1, 1], [1, 1.001]])  # ì¡°ê±´ìˆ˜ â‰ˆ 2000

b = np.array([1, 2])

# ì •í™•í•œ í•´
x_good_exact = np.linalg.lstsq(A_good, b, rcond=None)[0]
x_bad_exact = np.linalg.lstsq(A_bad, b, rcond=None)[0]

# ì‘ì€ ë…¸ì´ì¦ˆ ì¶”ê°€ (1%)
noise = 0.01 * np.random.randn(2)
b_noisy = b + noise

# ë…¸ì´ì¦ˆê°€ ìˆëŠ” í•´
x_good_noisy = np.linalg.lstsq(A_good, b_noisy, rcond=None)[0]
x_bad_noisy = np.linalg.lstsq(A_bad, b_noisy, rcond=None)[0]

# ì˜¤ì°¨ ë¹„êµ
error_good = np.linalg.norm(x_good_exact - x_good_noisy) / np.linalg.norm(x_good_exact)
error_bad = np.linalg.norm(x_bad_exact - x_bad_noisy) / np.linalg.norm(x_bad_exact)

print(f"ì¡°ê±´ìˆ˜ê°€ ì‘ì€ í–‰ë ¬ì˜ ì˜¤ì°¨: {error_good*100:.2f}%")
print(f"ì¡°ê±´ìˆ˜ê°€ í° í–‰ë ¬ì˜ ì˜¤ì°¨: {error_bad*100:.2f}%")
print(f"ì˜¤ì°¨ ì¦í­ ë¹„ìœ¨: {error_bad/error_good:.0f}ë°°")
```

#### ğŸ¤– SLAMì—ì„œì˜ ì¡°ê±´ìˆ˜ ì¤‘ìš”ì„±

**1. Bundle Adjustment**

```python
# ì¹´ë©”ë¼ í¬ì¦ˆì™€ 3D ì ì„ ë™ì‹œì— ìµœì í™”
# â†’ ì •ê·œ ë°©ì •ì‹(Normal Equation)ì˜ ì¡°ê±´ìˆ˜ê°€ ì¤‘ìš”

J = compute_jacobian(cameras, points)  # ì•¼ì½”ë¹„ì•ˆ
H = J.T @ J  # í—¤ì‹œì•ˆ (ì •ê·œ ë°©ì •ì‹)

U, s, Vt = np.linalg.svd(H)
cond = s[0] / s[-1]

if cond > 1e6:
    print("ê²½ê³ : ìµœì í™”ê°€ ë¶ˆì•ˆì •í•  ìˆ˜ ìˆìŒ")
    # â†’ Levenberg-Marquardt ì‚¬ìš© (ì •ê·œí™” ì¶”ê°€)
```

**2. Essential Matrix ê³„ì‚°**

```python
# 8-point ì•Œê³ ë¦¬ì¦˜
A = construct_constraint_matrix(pts1, pts2)
U, s, Vt = np.linalg.svd(A)

cond = s[0] / s[-1]
if cond > 1000:
    print("ê²½ê³ : íŠ¹ì§•ì  ë¶„í¬ê°€ ì¢‹ì§€ ì•ŠìŒ")
    print("â†’ ë” ë¶„ì‚°ëœ íŠ¹ì§•ì  í•„ìš”")
```

**3. ì‚¼ê°ì¸¡ëŸ‰(Triangulation)**

```python
# 3D ì  ë³µì›
A = construct_triangulation_matrix(p1, p2, P1, P2)
U, s, Vt = np.linalg.svd(A)

cond = s[0] / s[-1]
if cond > 100:
    print("ê²½ê³ : ì¹´ë©”ë¼ ê°ë„ê°€ ë„ˆë¬´ ì‘ìŒ")
    print("â†’ ë” í° ë² ì´ìŠ¤ë¼ì¸ í•„ìš”")
```

#### ğŸ› ï¸ ì¡°ê±´ìˆ˜ ê°œì„  ë°©ë²•

**1. ì •ê·œí™”(Normalization)**

```python
# ë°ì´í„°ë¥¼ í‰ê·  0, í‘œì¤€í¸ì°¨ 1ë¡œ ì •ê·œí™”
A_normalized = (A - A.mean(axis=0)) / A.std(axis=0)

# ì¡°ê±´ìˆ˜ ë¹„êµ
cond_before = np.linalg.cond(A)
cond_after = np.linalg.cond(A_normalized)
print(f"ì •ê·œí™” ì „: {cond_before:.0f}")
print(f"ì •ê·œí™” í›„: {cond_after:.0f}")
```

**2. ì •ê·œí™” í•­ ì¶”ê°€ (Regularization)**

```python
# Tikhonov ì •ê·œí™” (Ridge Regression)
Î» = 0.01  # ì •ê·œí™” íŒŒë¼ë¯¸í„°
A_reg = A.T @ A + Î» * np.eye(A.shape[1])

# ì¡°ê±´ìˆ˜ ê°œì„ 
cond_before = np.linalg.cond(A.T @ A)
cond_after = np.linalg.cond(A_reg)
print(f"ì •ê·œí™” ì „: {cond_before:.0f}")
print(f"ì •ê·œí™” í›„: {cond_after:.0f}")
```

**3. Preconditioning**

```python
# ëŒ€ê° ìŠ¤ì¼€ì¼ë§
D = np.diag(1 / np.sqrt(np.diag(A.T @ A)))
A_preconditioned = A @ D

cond_before = np.linalg.cond(A)
cond_after = np.linalg.cond(A_preconditioned)
```

#### ğŸ§® NumPyì—ì„œ ì¡°ê±´ìˆ˜ ê³„ì‚°

**ë°©ë²• 1: SVD ì‚¬ìš© (ê¶Œì¥)**

```python
U, s, Vt = np.linalg.svd(A)
cond = s[0] / s[-1]  # ê°€ì¥ ì •í™•
```

**ë°©ë²• 2: NumPy ë‚´ì¥ í•¨ìˆ˜**

```python
# L2 ë…¸ë¦„ ê¸°ì¤€ ì¡°ê±´ìˆ˜
cond = np.linalg.cond(A)  # ê¸°ë³¸ê°’: L2 norm

# ë‹¤ë¥¸ ë…¸ë¦„ ì‚¬ìš© ê°€ëŠ¥
cond_1 = np.linalg.cond(A, p=1)      # L1 norm
cond_inf = np.linalg.cond(A, p=np.inf)  # Lâˆ norm
cond_fro = np.linalg.cond(A, p='fro')   # Frobenius norm
```

#### âš¡ ì¡°ê±´ìˆ˜ì™€ íŠ¹ì´ê°’ì˜ ê´€ê³„

```python
import numpy as np
import matplotlib.pyplot as plt

# ë‹¤ì–‘í•œ ì¡°ê±´ìˆ˜ë¥¼ ê°€ì§„ í–‰ë ¬ ìƒì„±
condition_numbers = [1, 10, 100, 1000, 10000]

for Îº in condition_numbers:
    # íŠ¹ì´ê°’ ì„¤ì •: [Îº, 1]
    s = np.array([Îº, 1.0])
    
    # ëœë¤ ì§êµ í–‰ë ¬
    U, _ = np.linalg.qr(np.random.randn(2, 2))
    V, _ = np.linalg.qr(np.random.randn(2, 2))
    
    # A = U @ diag(s) @ V.T
    A = U @ np.diag(s) @ V.T
    
    cond_check = np.linalg.cond(A)
    print(f"ì„¤ì •í•œ ì¡°ê±´ìˆ˜: {Îº:5.0f}, ì‹¤ì œ: {cond_check:5.0f}")
```

#### ğŸ’¡ í•µì‹¬ ì •ë¦¬

1. **ì •ì˜**: ì¡°ê±´ìˆ˜ = Ïƒ_max / Ïƒ_min
   - ìµœëŒ€ íŠ¹ì´ê°’ Ã· ìµœì†Œ íŠ¹ì´ê°’

2. **ì˜ë¯¸**: ì…ë ¥ ì˜¤ì°¨ì˜ ì¦í­ ì •ë„
   - Îº = 1000 â†’ ì…ë ¥ 0.1% ì˜¤ì°¨ê°€ ìµœëŒ€ 100% ì˜¤ì°¨ë¡œ ì¦í­

3. **ê¸°ì¤€**:
   - Îº < 100: ì•ˆì • âœ…
   - Îº < 1000: ì£¼ì˜
   - Îº > 10â¶: ìœ„í—˜ ğŸš¨

4. **SLAM ì‘ìš©**:
   - Bundle Adjustment ì•ˆì •ì„± ê²€ì‚¬
   - íŠ¹ì§•ì  ë¶„í¬ í’ˆì§ˆ í‰ê°€
   - ì‚¼ê°ì¸¡ëŸ‰ ì •í™•ë„ ì˜ˆì¸¡

5. **ê°œì„  ë°©ë²•**:
   - ë°ì´í„° ì •ê·œí™”
   - ì •ê·œí™” í•­ ì¶”ê°€ (Tikhonov)
   - Preconditioning

> [!WARNING]
> **ì¡°ê±´ìˆ˜ê°€ í° í–‰ë ¬ì€ ì‘ì€ ì¸¡ì • ì˜¤ì°¨ë‚˜ ë¶€ë™ì†Œìˆ˜ì  ì—°ì‚° ì˜¤ì°¨ì—ë„ ê²°ê³¼ê°€ í¬ê²Œ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. SLAMì—ì„œëŠ” í•­ìƒ ì¡°ê±´ìˆ˜ë¥¼ ì²´í¬í•˜ê³ , í•„ìš”ì‹œ ì •ê·œí™”ë¥¼ ì ìš©í•´ì•¼ í•©ë‹ˆë‹¤!**

#### NumPy ë‚´ì¥ í•¨ìˆ˜ì™€ ë¹„êµ

```python
import numpy as np

A = np.array([[1, 2], [2, 4]])

# ë°©ë²• 1: SVDë¡œ ì§ì ‘ ê³„ì‚°
U, s, Vt = np.linalg.svd(A)
rank_svd = np.sum(s > 1e-10)

# ë°©ë²• 2: NumPyì˜ matrix_rank í•¨ìˆ˜
rank_numpy = np.linalg.matrix_rank(A)

print(f"SVD ê³„ì‚°: {rank_svd}")      # 1
print(f"NumPy í•¨ìˆ˜: {rank_numpy}")  # 1
print(f"ì¼ì¹˜: {rank_svd == rank_numpy}")  # True
```

> [!NOTE]
> `np.linalg.matrix_rank()`ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ SVDë¥¼ ì‚¬ìš©í•˜ë©°, ìë™ìœ¼ë¡œ ì ì ˆí•œ í—ˆìš© ì˜¤ì°¨ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

#### ğŸ’¡ í•µì‹¬ ì •ë¦¬

1. **ìˆ˜í•™ì  ì›ë¦¬**: í–‰ë ¬ì˜ ë­í¬ = 0ì´ ì•„ë‹Œ íŠ¹ì´ê°’ì˜ ê°œìˆ˜

2. **ì‹¤ì „ êµ¬í˜„**: `np.sum(s > tolerance)`
   - `tolerance`ëŠ” ìˆ˜ì¹˜ ì˜¤ì°¨ë¥¼ ê³ ë ¤í•œ ì„ê³„ê°’
   - ì¼ë°˜ì ìœ¼ë¡œ `1e-10` ì‚¬ìš©

3. **ì½”ë“œ ë™ì‘**:
   ```python
   s > 1e-10  # ë¶ˆë¦° ë°°ì—´: [True, True, False, ...]
   np.sum(...)  # True=1, False=0ìœ¼ë¡œ í•©ì‚°
   ```

4. **SLAM ì‘ìš©**:
   - Essential Matrix ê²€ì¦ (ë­í¬ = 2)
   - Homography ìœ íš¨ì„± (ë­í¬ = 3)
   - ë…¸ì´ì¦ˆ ì œê±° ë° ì •ê·œí™”

---

### ğŸ†š ê³ ìœ ê°’ ë¶„í•´ vs SVD

| | ê³ ìœ ê°’ ë¶„í•´ (EVD) | íŠ¹ì´ê°’ ë¶„í•´ (SVD) |
|--|------------------|------------------|
| **ì ìš© ê°€ëŠ¥** | ì •ë°© í–‰ë ¬ (nÃ—n)ë§Œ | **ëª¨ë“  í–‰ë ¬ (mÃ—n)** |
| **ë¶„í•´ í˜•íƒœ** | A = VÎ›Vâ»Â¹ | A = UÎ£Váµ€ |
| **U, V ê´€ê³„** | ê°™ì€ í–‰ë ¬ (V = V) | ë‹¤ë¥¸ í–‰ë ¬ (U â‰  V) |
| **ê°’ì˜ ë²”ìœ„** | ìŒìˆ˜ ê°€ëŠ¥ | **í•­ìƒ 0 ì´ìƒ** |
| **ëŒ€ì¹­ í–‰ë ¬ì¼ ë•Œ** | ê³ ìœ ê°’ = íŠ¹ì´ê°’ | ë™ì¼ |

---

### ğŸ¤– SLAMì—ì„œ ì™œ SVDë¥¼ ì“°ëŠ”ê°€?

**í•µì‹¬ ë¬¸ì œ:** `Ax = 0` í˜•íƒœì˜ ë°©ì •ì‹ì„ í’€ì–´ì•¼ í•¨

ì˜ˆ: 8ê°œì˜ ëŒ€ì‘ì ìœ¼ë¡œ Essential Matrixë¥¼ êµ¬í•  ë•Œ
```
[xâ‚‚xâ‚  xâ‚‚yâ‚  xâ‚‚  yâ‚‚xâ‚  yâ‚‚yâ‚  yâ‚‚  xâ‚  yâ‚  1] Ã— [eâ‚ eâ‚‚ ... eâ‚‰]áµ€ = 0
```

**SVDë¡œ Ax = 0ì˜ í•´ ì°¾ê¸°:**
```python
U, S, Vt = np.linalg.svd(A)

# ìµœì†Œ íŠ¹ì´ê°’ì— ëŒ€ì‘í•˜ëŠ” ë²¡í„° = Ax = 0ì˜ í•´
solution = Vt[-1]  # Vì˜ ë§ˆì§€ë§‰ í–‰ (= Vì˜ ë§ˆì§€ë§‰ ì—´)
```

**ì™œ ì´ê²Œ í•´ì¸ê°€?**
- Ax = 0ì˜ í•´ëŠ” Aì˜ **ì˜ê³µê°„(Null Space)** ì— ìˆìŒ
- ì˜ê³µê°„ = íŠ¹ì´ê°’ì´ 0ì¸ ë°©í–¥
- SVDì—ì„œ ë§ˆì§€ë§‰ íŠ¹ì´ê°’ì´ ê°€ì¥ ì‘ìœ¼ë¯€ë¡œ, **Vtì˜ ë§ˆì§€ë§‰ í–‰**ì´ ê°€ì¥ ê°€ê¹Œìš´ í•´!

---

### ğŸ“ SVDë¥¼ í•œ ë¬¸ì¥ìœ¼ë¡œ

> **"ì–´ë–¤ í–‰ë ¬ì´ë“  'íšŒì „ â†’ ìŠ¤ì¼€ì¼ â†’ íšŒì „'ìœ¼ë¡œ ë¶„í•´í•  ìˆ˜ ìˆê³ , íŠ¹ì´ê°’ì€ ê° ë°©í–¥ì˜ ì¤‘ìš”ë„ë¥¼ ì•Œë ¤ì¤€ë‹¤."**

---

## ğŸ”§ SVDì˜ í•µì‹¬ ì‘ìš©

### 1. ìµœì†ŒììŠ¹ í•´ (Least Squares Solution)

#### ğŸ“ ë¬¸ì œ ì •ì˜

**ê³¼ê²°ì • ì‹œìŠ¤í…œ(Overdetermined System)** ì€ ë°©ì •ì‹ì˜ ê°œìˆ˜ê°€ ë¯¸ì§€ìˆ˜ë³´ë‹¤ ë§ì€ ê²½ìš°ì…ë‹ˆë‹¤:

```
Ax = b
(mÃ—n) Ã— (nÃ—1) = (mÃ—1)
ì—¬ê¸°ì„œ m > n (ë°©ì •ì‹ ê°œìˆ˜ > ë¯¸ì§€ìˆ˜ ê°œìˆ˜)
```

ì´ ê²½ìš° **ì •í™•í•œ í•´ê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°ê°€ ëŒ€ë¶€ë¶„**ì´ë¯€ë¡œ, **ì”ì°¨(residual)ë¥¼ ìµœì†Œí™”**í•˜ëŠ” í•´ë¥¼ ì°¾ìŠµë‹ˆë‹¤.

#### ğŸ¯ ëª©í‘œ

ë‹¤ìŒì„ ìµœì†Œí™”í•˜ëŠ” xë¥¼ ì°¾ëŠ” ê²ƒ:

```
minimize ||Ax - b||Â² = (Ax - b)áµ€(Ax - b)
```

#### ğŸ’¡ ì§ê´€ì  ì˜ˆì‹œ: ì§ì„  í”¼íŒ…

```python
# ë°ì´í„°: (1, 2.1), (2, 2.9), (3, 4.2), (4, 4.8)
# ëª©í‘œ: y = a + bx í˜•íƒœì˜ ì§ì„  ì°¾ê¸°

A = np.array([
    [1, 1],   # yâ‚ = a + bÂ·1
    [1, 2],   # yâ‚‚ = a + bÂ·2
    [1, 3],   # yâ‚ƒ = a + bÂ·3
    [1, 4]    # yâ‚„ = a + bÂ·4
])
b = np.array([2.1, 2.9, 4.2, 4.8])

# 4ê°œ ë°©ì •ì‹, 2ê°œ ë¯¸ì§€ìˆ˜ â†’ ê³¼ê²°ì • ì‹œìŠ¤í…œ
# ëª¨ë“  ì ì„ ì •í™•íˆ ì§€ë‚˜ëŠ” ì§ì„ ì€ ì—†ìŒ!
```

#### âœ¨ SVDë¥¼ ì´ìš©í•œ í•´ë²•

**1ë‹¨ê³„: SVD ë¶„í•´**
```
A = U Î£ Váµ€
```

**2ë‹¨ê³„: ìœ ì‚¬ì—­í–‰ë ¬(Pseudoinverse) ê³„ì‚°**
```
Aâº = V Î£âº Uáµ€
```
ì—¬ê¸°ì„œ Î£âºëŠ” ê° Ïƒáµ¢ë¥¼ 1/Ïƒáµ¢ë¡œ ë°”ê¾¼ ê²ƒ (Ïƒáµ¢ â‰ˆ 0ì´ë©´ 0 ìœ ì§€)

**3ë‹¨ê³„: ìµœì†ŒììŠ¹ í•´**
```
x = Aâºb = V Î£âº Uáµ€ b
```

#### ğŸ’» êµ¬í˜„ ì˜ˆì œ

```python
import numpy as np

# ì§ì„  í”¼íŒ… ë¬¸ì œ
A = np.array([[1, 1], [1, 2], [1, 3], [1, 4]])
b = np.array([2.1, 2.9, 4.2, 4.8])

# ë°©ë²• 1: NumPy ìµœì†ŒììŠ¹ (ë‚´ë¶€ì ìœ¼ë¡œ SVD ì‚¬ìš©)
x_lstsq, residuals, _, _ = np.linalg.lstsq(A, b, rcond=None)
print(f"í•´: a = {x_lstsq[0]:.4f}, b = {x_lstsq[1]:.4f}")

# ë°©ë²• 2: SVDë¡œ ì§ì ‘ ê³„ì‚°
U, S, Vt = np.linalg.svd(A, full_matrices=False)
S_inv = np.diag(1 / S)
A_pinv = Vt.T @ S_inv @ U.T
x_svd = A_pinv @ b

# ì˜ˆì¸¡ê³¼ ì”ì°¨
y_pred = A @ x_lstsq
residual = b - y_pred
print(f"ì”ì°¨ ì œê³±í•©: {np.sum(residual**2):.6f}")
```

#### ğŸ“Š ì •ê·œë°©ì •ì‹ vs SVD

| | ì •ê·œë°©ì •ì‹ (Aáµ€A)â»Â¹Aáµ€b | SVD Aâºb |
|---|---|---|
| **ìˆ˜ì¹˜ ì•ˆì •ì„±** | ì¡°ê±´ìˆ˜ ì œê³± (ë¶ˆì•ˆì •) âš ï¸ | ì•ˆì •ì  âœ… |
| **ë­í¬ ë¶€ì¡±** | ì—­í–‰ë ¬ ì—†ìŒ âŒ | ìœ ì‚¬ì—­í–‰ë ¬ ì‚¬ìš© âœ… |
| **ì‘ì€ íŠ¹ì´ê°’** | í° ì˜¤ì°¨ ì¦í­ | ìë™ ì œê±° ê°€ëŠ¥ |

#### ğŸ¤– SLAMì—ì„œì˜ í™œìš©

- **í‰ë©´ í”¼íŒ…**: 3D ì ë“¤ë¡œë¶€í„° í‰ë©´ ë°©ì •ì‹ ì¶”ì •
- **ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜**: DLTë¡œ íˆ¬ì˜ í–‰ë ¬ ê³„ì‚°
- **ICP**: ë‘ ì êµ° ì •í•©ì—ì„œ ìµœì  R, t ì°¾ê¸°
- **Bundle Adjustment**: ì¹´ë©”ë¼ í¬ì¦ˆì™€ 3D ì  ë™ì‹œ ìµœì í™”

> [!TIP]
> SLAMì—ì„œëŠ” ê±°ì˜ í•­ìƒ **SVD ê¸°ë°˜ ìµœì†ŒììŠ¹**ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ë…¸ì´ì¦ˆê°€ ë§ê³  ì¡°ê±´ìˆ˜ê°€ ë‚˜ìœ ê²½ìš°ê°€ ë§ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤!

---

### 2. ì €ë­í¬ ê·¼ì‚¬ (Low-Rank Approximation)

```python
# ìƒìœ„ kê°œ íŠ¹ì´ê°’ë§Œ ì‚¬ìš©í•˜ì—¬ í–‰ë ¬ ê·¼ì‚¬
A_approx = U[:, :k] @ np.diag(S[:k]) @ Vt[:k, :]
```

### 3. Null Space (ì˜ê³µê°„) ì°¾ê¸°

```python
# Ax = 0ì˜ í•´ = Vì˜ ë§ˆì§€ë§‰ ì—´ (Ïƒ=0ì— ëŒ€ì‘í•˜ëŠ” ë²¡í„°)
null_space = Vt[-1, :]
```

---

## ğŸ¤– SLAM í•µì‹¬ ê°œë…ê³¼ SVD í™œìš©

Visual SLAMì—ì„œ SVDëŠ” ê¸°í•˜í•™ì  ë¬¸ì œë¥¼ í‘¸ëŠ” í•µì‹¬ ë„êµ¬ì…ë‹ˆë‹¤. ì•„ë˜ì—ì„œ ë„¤ ê°€ì§€ í•µì‹¬ ê°œë…ì„ ìì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

---

### 1. Essential Matrix (ê¸°ë³¸ í–‰ë ¬)

#### ê°œë…

**Essential Matrix (E)** ëŠ” ë‘ ì¹´ë©”ë¼ ì‚¬ì´ì˜ **ìƒëŒ€ì ì¸ íšŒì „(R)ê³¼ í‰í–‰ì´ë™(t)** ì„ ì¸ì½”ë”©í•œ 3Ã—3 í–‰ë ¬ì…ë‹ˆë‹¤.

```
ë‘ ì´ë¯¸ì§€ì—ì„œ ëŒ€ì‘ì  pâ‚, pâ‚‚ê°€ ìˆì„ ë•Œ:
pâ‚‚áµ€ Â· E Â· pâ‚ = 0  (Epipolar Constraint)
```

#### ê¸°í•˜í•™ì  ì˜ë¯¸

```
          ì—í”¼í´ë¼ í‰ë©´
         /          \
        /            \
   ì¹´ë©”ë¼1 -------- ì¹´ë©”ë¼2
       \    3D ì     /
        \     P     /
         \   /\   /
          \ /  \ /
          pâ‚    pâ‚‚
       (ì´ë¯¸ì§€1) (ì´ë¯¸ì§€2)
```

- 3D ì  Pì™€ ë‘ ì¹´ë©”ë¼ ì¤‘ì‹¬ì„ ì‡ëŠ” **ì—í”¼í´ë¼ í‰ë©´**
- pâ‚‚ëŠ” ë°˜ë“œì‹œ **ì—í”¼í´ë¼ ë¼ì¸** ìœ„ì— ìˆì–´ì•¼ í•¨
- EëŠ” ì´ ê¸°í•˜í•™ì  ì œì•½ì„ ìˆ˜í•™ì ìœ¼ë¡œ í‘œí˜„

#### Eì˜ ì„±ì§ˆ

| ì„±ì§ˆ | ì„¤ëª… |
|------|------|
| ë­í¬ = 2 | ì„¸ ë²ˆì§¸ íŠ¹ì´ê°’ì´ 0 |
| íŠ¹ì´ê°’ | [Ïƒ, Ïƒ, 0] í˜•íƒœ (ë‘ ê°œê°€ ë™ì¼) |
| ììœ ë„ | 5 DOF (3 íšŒì „ + 2 ë°©í–¥, ìŠ¤ì¼€ì¼ ë¶ˆê°€) |

#### SVDë¡œ R, t ì¶”ì¶œ

```python
import numpy as np

def decompose_essential_matrix(E):
    """Essential Matrixì—ì„œ R, t ì¶”ì¶œ"""
    U, S, Vt = np.linalg.svd(E)
    
    # íŠ¹ì´ê°’ ë³´ì •: [Ïƒ, Ïƒ, 0] í˜•íƒœë¡œ ê°•ì œ
    S_corrected = np.diag([1, 1, 0])
    E_corrected = U @ S_corrected @ Vt
    
    # W í–‰ë ¬ (90ë„ íšŒì „)
    W = np.array([
        [0, -1, 0],
        [1, 0, 0],
        [0, 0, 1]
    ])
    
    # 4ê°€ì§€ ê°€ëŠ¥í•œ í•´
    R1 = U @ W @ Vt
    R2 = U @ W.T @ Vt
    t1 = U[:, 2]
    t2 = -U[:, 2]
    
    # det(R) = 1 ë³´ì¥
    if np.linalg.det(R1) < 0:
        R1 = -R1
    if np.linalg.det(R2) < 0:
        R2 = -R2
    
    return [(R1, t1), (R1, t2), (R2, t1), (R2, t2)]
```

> [!IMPORTANT]
> **Cheirality Check**: 4ê°œì˜ (R, t) í›„ë³´ ì¤‘ **3D ì ì´ ë‘ ì¹´ë©”ë¼ ì•ì— ìˆëŠ”** ê²½ìš°ë§Œ ìœ íš¨í•©ë‹ˆë‹¤. Triangulation í›„ ì–‘ì˜ ê¹Šì´ë¥¼ ê°–ëŠ” í•´ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.

#### 8ì  ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ E ê³„ì‚°

```python
def compute_essential_8point(pts1, pts2):
    """8ì  ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ Essential Matrix ê³„ì‚°"""
    # Ax = 0 í˜•íƒœë¡œ ë³€í™˜ (xëŠ” Eì˜ 9ê°œ ì›ì†Œ)
    A = []
    for p1, p2 in zip(pts1, pts2):
        x1, y1 = p1
        x2, y2 = p2
        A.append([x2*x1, x2*y1, x2, y2*x1, y2*y1, y2, x1, y1, 1])
    A = np.array(A)
    
    # SVDë¡œ null space ì°¾ê¸°
    U, S, Vt = np.linalg.svd(A)
    E = Vt[-1].reshape(3, 3)  # ìµœì†Œ íŠ¹ì´ê°’ì— ëŒ€ì‘í•˜ëŠ” ë²¡í„°
    
    # ë­í¬ 2 ì œì•½ ì ìš©
    U, S, Vt = np.linalg.svd(E)
    E = U @ np.diag([S[0], S[1], 0]) @ Vt
    
    return E
```

---

### 2. Homography (í˜¸ëª¨ê·¸ë˜í”¼)

#### ê°œë…

**Homography (H)** ëŠ” **ë™ì¼ í‰ë©´ ìœ„ì˜ ì ë“¤** ë˜ëŠ” **ìˆœìˆ˜ íšŒì „** ì¼ ë•Œ, ë‘ ì´ë¯¸ì§€ ê°„ì˜ ë³€í™˜ì„ ë‚˜íƒ€ë‚´ëŠ” 3Ã—3 í–‰ë ¬ì…ë‹ˆë‹¤.

```
ë™ì°¨ ì¢Œí‘œë¡œ: pâ‚‚ ~ H Â· pâ‚
(~ëŠ” ìŠ¤ì¼€ì¼ ë¶ˆë³€ ë™ì¹˜)
```

#### ê¸°í•˜í•™ì  ì˜ë¯¸

```
        í‰ë©´ (Ï€)
       +--------+
      /|       /|
     / |      / |
    +--+-----+  |
    | 3D ì ë“¤ | |
    |  (ë™ì¼  | /
    |  í‰ë©´)  |/
    +---------+
       â†“ â†“
  ì´ë¯¸ì§€1  ì´ë¯¸ì§€2
```

- í‰ë©´ ìœ„ì˜ ì ë“¤ë§Œ ê³ ë ¤í•  ë•Œ ì„±ë¦½
- ì˜ˆ: ë°”ë‹¥, ë²½, í¬ìŠ¤í„° ë“± í‰ë©´ ë¬¼ì²´

#### Homography ì ìš© ì‚¬ë¡€

| ìƒí™© | ì„¤ëª… |
|------|------|
| í‰ë©´ ë¬¼ì²´ | ë°”ë‹¥ë©´, ë²½ë©´ì˜ íŠ¹ì§•ì  ë§¤ì¹­ |
| ìˆœìˆ˜ íšŒì „ | ì¹´ë©”ë¼ê°€ ì œìë¦¬ì—ì„œë§Œ íšŒì „ |
| ì´ë¯¸ì§€ ì •í•© | íŒŒë…¸ë¼ë§ˆ ìŠ¤í‹°ì¹­ |
| AR ë§ˆì»¤ | í‰ë©´ ë§ˆì»¤ í¬ì¦ˆ ì¶”ì • |

#### DLT (Direct Linear Transform)ë¡œ H ê³„ì‚°

```python
def compute_homography_dlt(pts1, pts2):
    """DLT ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ Homography ê³„ì‚°"""
    A = []
    for (x1, y1), (x2, y2) in zip(pts1, pts2):
        A.append([-x1, -y1, -1, 0, 0, 0, x2*x1, x2*y1, x2])
        A.append([0, 0, 0, -x1, -y1, -1, y2*x1, y2*y1, y2])
    A = np.array(A)
    
    # SVDë¡œ null space ì°¾ê¸°
    U, S, Vt = np.linalg.svd(A)
    H = Vt[-1].reshape(3, 3)
    
    # ì •ê·œí™” (H[2,2] = 1)
    H = H / H[2, 2]
    
    return H
```

#### Homography ë¶„í•´

```python
def decompose_homography(H, K):
    """Homographyì—ì„œ R, t, n ì¶”ì¶œ (ì¹´ë©”ë¼ ë‚´ë¶€ íŒŒë¼ë¯¸í„° K í•„ìš”)"""
    # ì •ê·œí™”ëœ homography
    H_normalized = np.linalg.inv(K) @ H @ K
    
    # SVD ë¶„í•´
    U, S, Vt = np.linalg.svd(H_normalized)
    
    # ìŠ¤ì¼€ì¼ ë³´ì •
    H_normalized = H_normalized / S[1]
    
    # ì—¬ëŸ¬ í•´ ì¤‘ ì„ íƒ í•„ìš” (ë³µì¡í•œ ë¶„í•´ ê³¼ì •)
    # OpenCV: cv2.decomposeHomographyMat() ì‚¬ìš© ê¶Œì¥
    return decomposed_solutions
```

---

### 3. PnP (Perspective-n-Point)

#### ê°œë…

**PnP**ëŠ” **nê°œì˜ 3D-2D ëŒ€ì‘ì **ì´ ì£¼ì–´ì¡Œì„ ë•Œ, **ì¹´ë©”ë¼ í¬ì¦ˆ(R, t)ë¥¼ ì¶”ì •**í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

```
ì…ë ¥: 3D ì  {Páµ¢} (ì›”ë“œ ì¢Œí‘œê³„), 2D ì  {páµ¢} (ì´ë¯¸ì§€)
ì¶œë ¥: ì¹´ë©”ë¼ í¬ì¦ˆ [R | t]
```

#### ê¸°í•˜í•™ì  ì˜ë¯¸

```
        ì›”ë“œ ì¢Œí‘œê³„
           Pâ‚ â—
              \
               \  â† 3D ì ë“¤ì˜ ìœ„ì¹˜ë¥¼ ì•Œê³  ìˆìŒ
                \
    Pâ‚‚ â—---------+-------- Pâ‚ƒ â—
                 |
                 | â† ì–´ë””ì„œ ì´¬ì˜í–ˆì„ê¹Œ?
                 |
              [ì¹´ë©”ë¼]
                 â†“
             ì´ë¯¸ì§€ (pâ‚, pâ‚‚, pâ‚ƒ)
```

#### PnP ë¬¸ì œì˜ ì¢…ë¥˜

| ìµœì†Œ ì  ìˆ˜ | ì•Œê³ ë¦¬ì¦˜ | íŠ¹ì§• |
|-----------|----------|------|
| 3ì  (P3P) | P3P | ìµœì†Œ í•´, ìµœëŒ€ 4ê°œ í•´ |
| 4ì  (P4P) | ë‹¤ì–‘ | EPnP, DLT ë“± |
| nì  | EPnP, DLT | ê³¼ê²°ì • ì‹œìŠ¤í…œ, ìµœì†ŒììŠ¹ |

#### DLT ê¸°ë°˜ PnP (SVD í™œìš©)

```python
def pnp_dlt(pts_3d, pts_2d, K):
    """DLT ê¸°ë°˜ PnP í’€ì´"""
    # ì¹´ë©”ë¼ ë‚´ë¶€ íŒŒë¼ë¯¸í„°ë¡œ ì •ê·œí™”
    pts_2d_normalized = []
    K_inv = np.linalg.inv(K)
    for p in pts_2d:
        p_h = np.array([p[0], p[1], 1])
        p_n = K_inv @ p_h
        pts_2d_normalized.append(p_n[:2])
    
    # A í–‰ë ¬ êµ¬ì„±
    A = []
    for P, p in zip(pts_3d, pts_2d_normalized):
        X, Y, Z = P
        u, v = p
        A.append([X, Y, Z, 1, 0, 0, 0, 0, -u*X, -u*Y, -u*Z, -u])
        A.append([0, 0, 0, 0, X, Y, Z, 1, -v*X, -v*Y, -v*Z, -v])
    A = np.array(A)
    
    # SVDë¡œ í•´ êµ¬í•˜ê¸°
    U, S, Vt = np.linalg.svd(A)
    P_matrix = Vt[-1].reshape(3, 4)
    
    # R, t ì¶”ì¶œ ë° R ì •ê·œí™”
    R = P_matrix[:, :3]
    t = P_matrix[:, 3]
    
    # SVDë¡œ ê°€ì¥ ê°€ê¹Œìš´ íšŒì „ í–‰ë ¬ ì°¾ê¸°
    U_r, _, Vt_r = np.linalg.svd(R)
    R = U_r @ Vt_r
    if np.linalg.det(R) < 0:
        R = -R
        t = -t
    
    return R, t
```

#### OpenCVì—ì„œ PnP

```python
import cv2

# solvePnP: ë°˜ë³µì  ìµœì í™”
success, rvec, tvec = cv2.solvePnP(
    pts_3d, pts_2d, K, dist_coeffs,
    flags=cv2.SOLVEPNP_ITERATIVE
)

# solvePnPRansac: RANSACìœ¼ë¡œ ì•„ì›ƒë¼ì´ì–´ ì œê±°
success, rvec, tvec, inliers = cv2.solvePnPRansac(
    pts_3d, pts_2d, K, dist_coeffs
)
```

---

### 4. Triangulation (ì‚¼ê°ì¸¡ëŸ‰)

#### ê°œë…

**Triangulation**ì€ **ë‘ ê°œ ì´ìƒì˜ ì¹´ë©”ë¼ì—ì„œ ê´€ì¸¡ëœ 2D ì **ìœ¼ë¡œë¶€í„° **3D ì  ìœ„ì¹˜ë¥¼ ë³µì›**í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

```
ì…ë ¥: 2D ì  pâ‚, pâ‚‚ + ì¹´ë©”ë¼ í–‰ë ¬ Pâ‚, Pâ‚‚
ì¶œë ¥: 3D ì  X
```

#### ê¸°í•˜í•™ì  ì˜ë¯¸

```
          3D ì  X â— (ì•Œê³  ì‹¶ì€ ê²ƒ)
                / \
               /   \
           ê´‘ì„ 1    ê´‘ì„ 2
             /       \
            /         \
       ì¹´ë©”ë¼1      ì¹´ë©”ë¼2
          â†“           â†“
         pâ‚           pâ‚‚
      (ê´€ì¸¡)        (ê´€ì¸¡)
```

- ì´ìƒì ìœ¼ë¡œ ë‘ ê´‘ì„ ì´ 3D ì ì—ì„œ êµì°¨
- ì‹¤ì œë¡œëŠ” **ë…¸ì´ì¦ˆë¡œ ì¸í•´ êµì°¨í•˜ì§€ ì•ŠìŒ**
- â†’ ìµœì†ŒììŠ¹ í•´ë¡œ ê·¼ì‚¬

#### Linear Triangulation (DLT)

```python
def triangulate_dlt(p1, p2, P1, P2):
    """DLT ê¸°ë°˜ Triangulation
    
    Args:
        p1, p2: 2D ì  (ì •ê·œí™”ëœ ì¢Œí‘œ)
        P1, P2: ì¹´ë©”ë¼ íˆ¬ì˜ í–‰ë ¬ (3x4)
    
    Returns:
        X: 3D ì  (ë™ì°¨ ì¢Œí‘œ)
    """
    x1, y1 = p1
    x2, y2 = p2
    
    # A í–‰ë ¬ êµ¬ì„± (ê° ëŒ€ì‘ì ë§ˆë‹¤ 2ê°œ ë°©ì •ì‹)
    A = np.array([
        x1 * P1[2] - P1[0],
        y1 * P1[2] - P1[1],
        x2 * P2[2] - P2[0],
        y2 * P2[2] - P2[1]
    ])
    
    # SVDë¡œ AX = 0ì˜ í•´ êµ¬í•˜ê¸°
    U, S, Vt = np.linalg.svd(A)
    X = Vt[-1]  # ìµœì†Œ íŠ¹ì´ê°’ì— ëŒ€ì‘í•˜ëŠ” ë²¡í„°
    
    # ë™ì°¨ ì¢Œí‘œ â†’ ìœ í´ë¦¬ë“œ ì¢Œí‘œ
    X = X / X[3]
    
    return X[:3]
```

#### ê¹Šì´ ê²€ì¦ (Cheirality Check)

```python
def check_cheirality(X, R, t):
    """3D ì ì´ ì¹´ë©”ë¼ ì•ì— ìˆëŠ”ì§€ í™•ì¸"""
    # ì¹´ë©”ë¼ ì¢Œí‘œê³„ì—ì„œì˜ ì 
    X_cam = R @ X + t
    
    # Z > 0ì´ë©´ ì¹´ë©”ë¼ ì•ì— ìˆìŒ
    return X_cam[2] > 0
```

#### OpenCVì—ì„œ Triangulation

```python
import cv2

# íˆ¬ì˜ í–‰ë ¬
P1 = K @ np.hstack([np.eye(3), np.zeros((3, 1))])
P2 = K @ np.hstack([R, t.reshape(3, 1)])

# Triangulation
pts_4d = cv2.triangulatePoints(P1, P2, pts1.T, pts2.T)

# ë™ì°¨ ì¢Œí‘œ â†’ ìœ í´ë¦¬ë“œ ì¢Œí‘œ
pts_3d = pts_4d[:3] / pts_4d[3]
```

---

### ìš”ì•½: ë„¤ ê°€ì§€ ë¬¸ì œì˜ ê´€ê³„

```mermaid
graph TD
    A[íŠ¹ì§•ì  ë§¤ì¹­] --> B{ì¥ë©´ ìœ í˜•}
    B -->|í‰ë©´/ìˆœìˆ˜íšŒì „| C[Homography]
    B -->|ì¼ë°˜ ì¥ë©´| D[Essential Matrix]
    
    C --> E[R, t ì¶”ì¶œ]
    D --> E
    
    E --> F[Triangulation]
    F --> G[3D ì  ë³µì›]
    
    G --> H[PnP]
    H --> I[ìƒˆ í”„ë ˆì„ í¬ì¦ˆ ì¶”ì •]
```

| ë¬¸ì œ | ì…ë ¥ | ì¶œë ¥ | SVD ì—­í•  |
|------|------|------|----------|
| **Essential Matrix** | 2D-2D ëŒ€ì‘ì  | E í–‰ë ¬ | Ax=0 í•´, R/t ë¶„í•´ |
| **Homography** | 2D-2D ëŒ€ì‘ì  (í‰ë©´) | H í–‰ë ¬ | Ax=0 í•´, ë¶„í•´ |
| **Triangulation** | 2D-2D + ì¹´ë©”ë¼ í¬ì¦ˆ | 3D ì  | Ax=0 í•´ |
| **PnP** | 3D-2D ëŒ€ì‘ì  | ì¹´ë©”ë¼ í¬ì¦ˆ | DLT í•´, R ì •ê·œí™” |

---

## ğŸ’» ì‹¤ìŠµ íŒŒì¼

ì´ í´ë”ì— í¬í•¨ëœ ì‹¤ìŠµ íŒŒì¼:

| íŒŒì¼ | ë‚´ìš© |
|------|------|
| `svd_basics.py` | SVD ê¸°ë³¸ ê°œë… ë° ê¸°í•˜í•™ì  ì˜ë¯¸ ì‹¤ìŠµ |
| `svd_quiz.py` | ì£¼ê´€ì‹ í€´ì¦ˆ (ë¬¸ì œ/ë‹µì•ˆ ë¶„ë¦¬) |

### ì‹¤í–‰ ë°©ë²•

```bash
cd studies/phase1_math/week3
python3 svd_basics.py
python3 svd_quiz.py
```

---

## ğŸ¬ ì¶”ì²œ ì˜ìƒ

| ì˜ìƒ | ì„¤ëª… |
|------|------|
| [3Blue1Brown - But what is the SVD?](https://www.youtube.com/watch?v=vSczTbgc8Rc) | SVD ì§ê´€ ì´í•´ (í•„ìˆ˜!) |
| [Steve Brunton - SVD](https://www.youtube.com/watch?v=gXbThCXjZFM) | ê³µí•™ì  ê´€ì ì—ì„œì˜ SVD |
| [Cyrill Stachniss - Essential Matrix](https://www.youtube.com/watch?v=zX5NeY-GTO0) | SLAMì—ì„œ Essential Matrix |

---

## âœ… í•™ìŠµ ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] SVDì˜ ê¸°í•˜í•™ì  ì˜ë¯¸ë¥¼ "íšŒì „-ìŠ¤ì¼€ì¼-íšŒì „"ìœ¼ë¡œ ì„¤ëª…í•  ìˆ˜ ìˆë‹¤
- [ ] íŠ¹ì´ê°’ì´ 0ì¸ ê²ƒê³¼ ë­í¬ì˜ ê´€ê³„ë¥¼ ì„¤ëª…í•  ìˆ˜ ìˆë‹¤
- [ ] NumPyë¡œ SVD ë¶„í•´ë¥¼ ìˆ˜í–‰í•˜ê³  ê²°ê³¼ë¥¼ í•´ì„í•  ìˆ˜ ìˆë‹¤
- [ ] Essential Matrixì—ì„œ R, t ì¶”ì¶œì— SVDê°€ ì™œ í•„ìš”í•œì§€ ì´í•´í•œë‹¤
- [ ] Ax = 0 í˜•íƒœì˜ ë¬¸ì œì—ì„œ ì˜ê³µê°„(null space)ì„ SVDë¡œ êµ¬í•  ìˆ˜ ìˆë‹¤

---

## ğŸ”— ë‹¤ìŒ ë‹¨ê³„

Week 3 ì™„ë£Œ í›„ â†’ **Week 4: íšŒì „ í‘œí˜„**ìœ¼ë¡œ ì´ë™
- íšŒì „ í–‰ë ¬, ì˜¤ì¼ëŸ¬ ê°, ì¿¼í„°ë‹ˆì–¸ í•™ìŠµ
- SVDê°€ íšŒì „ í–‰ë ¬ ì •ê·œí™”ì—ë„ ì‚¬ìš©ë¨ì„ í™•ì¸
